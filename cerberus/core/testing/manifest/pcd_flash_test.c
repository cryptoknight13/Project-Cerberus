// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include "testing.h"
#include "manifest/pcd/pcd_flash.h"
#include "manifest/pcd/pcd_format.h"
#include "cmd_interface/device_manager.h"
#include "flash/flash.h"
#include "testing/mock/crypto/signature_verification_mock.h"
#include "testing/engines/hash_testing_engine.h"
#include "testing/manifest/pcd_testing.h"
#include "testing/manifest/manifest_flash_v2_testing.h"


TEST_SUITE_LABEL ("pcd_flash");


/**
 * PCD with ID 0x1A for testing.
 */
const uint8_t PCD_DATA[] = {
	0x9c,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x50,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x5c,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x70,0x01,0x14,0x00,
	0x40,0xff,0x01,0x04,0x84,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x8c,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0x94,0x01,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,
	0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,
	0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,
	0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,
	0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0x62,0xbc,0xfb,0x2c,0xb5,0xf6,0x05,0x81,
	0xfc,0xc5,0x0d,0x37,0xe5,0x34,0xc4,0xdc,0xe9,0xee,0xc5,0x28,0x41,0x62,0x1d,0xd8,
	0xc7,0x06,0x6d,0x23,0xca,0x9b,0x6a,0x45,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,
	0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,
	0x00,0x70,0xf0,0x04,0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,
	0x02,0x30,0x00,0x00,0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,
	0x00,0x48,0xe8,0x01,0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,0x21,0x7e,0x4b,0xd3,
	0x2d,0xf8,0x1f,0x06,0x61,0x25,0xa8,0x6e,0x5b,0xb2,0xe3,0xa1,0x46,0xb1,0xe5,0x95,
	0x0e,0x9e,0x7a,0x19,0x9b,0x74,0x86,0xbe,0x2a,0x12,0xe4,0xcc,0x8f,0x91,0x3e,0x7c,
	0x1f,0x7a,0x4d,0xa4,0x38,0xbc,0x5a,0xce,0xaa,0xb1,0xd2,0x4f,0xe8,0xa9,0x8c,0x14,
	0xda,0x6b,0x46,0x28,0x76,0x09,0x7d,0xbc,0x35,0xac,0x3c,0x87,0xfd,0x5f,0x96,0x8a,
	0x95,0xae,0x1d,0x83,0xca,0x0e,0x75,0xaf,0x55,0x15,0xfa,0x83,0x92,0xda,0xd3,0x90,
	0x75,0xea,0x8a,0x20,0x91,0x33,0x9b,0xa7,0xee,0x08,0x75,0x64,0x36,0xaa,0x56,0x11,
	0x51,0x65,0x5e,0xd6,0x47,0x9a,0xfd,0xe4,0xfa,0xa4,0xfe,0x0e,0x99,0x81,0x22,0x5c,
	0x67,0x15,0x97,0x7c,0xef,0xa6,0x45,0x86,0xcf,0xde,0x94,0x21,0xd6,0x6b,0x1b,0x0f,
	0x3c,0x2e,0x16,0x17,0x41,0x30,0xb9,0xab,0xa1,0x60,0x30,0x47,0x57,0x68,0x3e,0xc2,
	0x3a,0xd8,0x13,0xe5,0xe9,0xce,0xb6,0x43,0x64,0xfa,0xa9,0x64,0x15,0xd7,0x8e,0x27,
	0x07,0x0d,0x5b,0x97,0xd0,0x8a,0x51,0xb6,0x66,0x80,0xf3,0x0f,0x47,0xf0,0xf0,0x4b,
	0x23,0xff,0x70,0xb5,0xe0,0x03,0xb1,0xb5,0x5b,0x1f,0x44,0xe8,0x02,0xdb,0x3f,0xb0,
	0xc2,0xdb,0x4f,0x68,0xcf,0x72,0xc0,0x7f,0xef,0xcc,0xf5,0xc3,0x81,0x31,0x8a,0xd3,
	0xe9,0x2c,0x57,0x8b,0x53,0x97,0x1d,0x08,0xe6,0x4c,0x38,0xd0,0xdd,0x36,0x3f,0x6b,
	0x69,0x22,0x64,0x7c,0x3b,0x28,0xbc,0x0d,0xf4,0xa8,0x21,0x51,0x97,0x5c,0x38,0xff,
	0x5c,0xed,0xf4,0x4d,0x8b,0x99,0xc5,0xda,0x27,0x4f,0xd6,0x7f
};

/**
 * Length of the testing PCD.
 */
const uint32_t PCD_DATA_LEN = sizeof (PCD_DATA);

/**
 * PCD_DATA hash for testing.
 */
const uint8_t PCD_HASH[] = {
	0xb3,0xdb,0xed,0xb3,0x02,0xc2,0x19,0xd7,0x56,0xf1,0x30,0xed,0xad,0xc6,0x9a,0xc2,
	0x75,0xd6,0xe8,0x55,0x71,0x90,0xb6,0xcb,0xda,0x19,0xf8,0x1b,0xee,0xba,0x23,0xb2
};

/**
 * The platform ID for the PCD.
 */
const char PCD_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD.
 */
const struct pcd_testing_data PCD_TESTING = {
	.manifest = {
		.raw = PCD_DATA,
		.length = sizeof (PCD_DATA),
		.hash = PCD_HASH,
		.hash_len = sizeof (PCD_HASH),
		.id = 0x1a,
		.signature = PCD_DATA + (sizeof (PCD_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_DATA + 0x0148,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0184,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0150,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x0170,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x015c,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x018c,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * PCD with ID 0x1B for testing.
 */
const uint8_t PCD_SKU_SPECIFIC_DATA[] = {
	0xa8,0x02,0x29,0x10,0x1b,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x14,0x00,0x42,0xff,0x01,0x01,0x5c,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x68,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x7c,0x01,0x14,0x00,
	0x40,0xff,0x01,0x04,0x90,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x98,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0xa0,0x01,0x08,0x00,0xe4,0xc5,0x49,0x98,0xd4,0x44,0xf5,0xcd,
	0x14,0x74,0x83,0xe3,0xb0,0x2c,0x87,0xf0,0xf9,0x54,0xaf,0x79,0xa1,0xa0,0x6e,0xad,
	0xe1,0x57,0xfb,0xfb,0xd8,0xd0,0xdb,0xba,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,
	0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,
	0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,
	0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,
	0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0xfb,0x1b,0x0e,0x4a,0xf9,0xb2,0x92,0x51,
	0xe8,0xf8,0x2b,0xde,0xea,0x1d,0x72,0x71,0x50,0xc4,0x32,0x2e,0x80,0xb4,0xa9,0x0a,
	0xc4,0x6b,0xb8,0xbe,0x49,0x1d,0x85,0xc0,0x0d,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x2d,0x53,0x70,0x65,0x63,0x69,0x66,0x69,0x63,0x00,0x00,0x00,0x02,0x02,0x22,0x14,
	0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,0x41,0x6c,0x70,0x68,
	0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,0x00,0x70,0xf0,0x04,
	0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,
	0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,
	0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,0x5b,0x59,0x34,0x80,0xcc,0xf1,0x0b,0x1f,
	0x01,0x4c,0x4d,0x08,0xf5,0xaa,0xd1,0xab,0x30,0xc6,0xcd,0x82,0x38,0xe3,0x16,0x48,
	0x1f,0xd0,0x10,0x04,0xeb,0xe3,0x76,0x04,0xf2,0x3d,0x57,0x9c,0x25,0x57,0xd1,0x4b,
	0x6f,0xfc,0x94,0xfc,0x1a,0x52,0x2d,0x30,0xe5,0x91,0x6b,0xe3,0xe3,0x69,0xa5,0x6b,
	0x13,0x59,0xf3,0x15,0xbc,0x8a,0xec,0x90,0x16,0x89,0x85,0xda,0x7a,0xcb,0x6d,0x4f,
	0xe5,0x81,0x3a,0x2b,0x85,0xc7,0x02,0xb6,0xc3,0xc8,0xa3,0xd2,0x68,0x50,0x5f,0x9f,
	0xa7,0x9a,0xfb,0x9e,0xa5,0x0f,0x94,0xd9,0x48,0xcc,0x5e,0x09,0x5b,0x53,0xd8,0x5b,
	0x2b,0x4c,0x99,0x45,0x8c,0x73,0x84,0x3f,0x5b,0x85,0xa4,0x48,0xe6,0xb6,0x91,0x87,
	0x08,0x73,0xc8,0x91,0xfd,0x17,0x84,0x47,0x4b,0x6f,0xec,0xe8,0x00,0xe0,0x12,0x66,
	0x34,0x92,0x88,0x5a,0xac,0x72,0x3e,0x0f,0x84,0x48,0x2f,0xf0,0xcc,0x17,0x75,0x9b,
	0x75,0x58,0xd8,0xa4,0x2a,0x76,0xe9,0xfd,0xc0,0xdd,0x18,0x3f,0x63,0xd6,0x84,0x22,
	0x77,0xba,0x64,0x16,0xf0,0xbe,0x25,0xcb,0x12,0xc4,0x91,0xd0,0x85,0xaa,0x98,0x7f,
	0xea,0xbe,0xb3,0xb4,0x47,0xb9,0x9d,0x8e,0x5c,0xbb,0xf7,0x82,0x6b,0x36,0x9a,0x06,
	0x56,0xf7,0x0f,0x41,0x25,0x5a,0xa3,0xda,0x76,0x9a,0x20,0x8a,0x2d,0x70,0x33,0x00,
	0xd4,0xd8,0x1f,0x51,0x6d,0x1d,0x46,0xaa,0xb5,0x4a,0xd2,0x8e,0x8f,0xc1,0x6f,0x8b,
	0x89,0x2b,0xa9,0x1f,0xf7,0x40,0x78,0x83,0x47,0x6c,0xd0,0x56,0xaa,0x46,0x1c,0xac,
	0xeb,0x3a,0xd2,0x82,0xb8,0xd8,0x8c,0x01
};

/**
 * Length of the testing PCD.
 */
const uint32_t PCD_SKU_SPECIFIC_DATA_LEN = sizeof (PCD_SKU_SPECIFIC_DATA);

/**
 * PCD_SKU_SPECIFIC_DATA hash for testing.
 */
const uint8_t PCD_SKU_SPECIFIC_HASH[] = {
	0x65,0x99,0x6a,0xad,0xc5,0x53,0x30,0x58,0xee,0xd1,0x69,0x3b,0xe1,0xc2,0xb9,0xe6,
	0xd5,0xfb,0x4f,0xd7,0xc9,0x12,0xde,0x28,0x2d,0x0b,0xe2,0x7d,0x26,0xde,0x7d,0x41
};

/**
 * The platform ID for the PCD.
 */
const char PCD_SKU_SPECIFIC_PLATFORM_ID[] = "SKU1-Specific";

/**
 * Components of the test PCD.
 */
const struct pcd_testing_data PCD_SKU_SPECIFIC_TESTING = {
	.manifest = {
		.raw = PCD_SKU_SPECIFIC_DATA,
		.length = sizeof (PCD_SKU_SPECIFIC_DATA),
		.hash = PCD_SKU_SPECIFIC_HASH,
		.hash_len = sizeof (PCD_SKU_SPECIFIC_HASH),
		.id = 0x1b,
		.signature = PCD_SKU_SPECIFIC_DATA + (sizeof (PCD_SKU_SPECIFIC_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_SKU_SPECIFIC_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_SKU_SPECIFIC_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_SKU_SPECIFIC_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_SKU_SPECIFIC_DATA + 0x0148,
		.plat_id_len = 0x0014,
		.plat_id_str = PCD_SKU_SPECIFIC_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_SKU_SPECIFIC_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0190,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x015c,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x017c,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x0168,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x0198,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * PCD with no POWER_CONTROLLER for testing.
 */
const uint8_t PCD_NO_POWER_CONTROLLER_DATA[] = {
	0x68,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,0x06,0x00,0x00,
	0x00,0xff,0x01,0x00,0x20,0x01,0x08,0x00,0x43,0xff,0x01,0x01,0x28,0x01,0x14,0x00,
	0x44,0xff,0x01,0x02,0x3c,0x01,0x14,0x00,0x40,0xff,0x01,0x03,0x50,0x01,0x08,0x00,
	0x41,0x40,0x01,0x04,0x58,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x60,0x01,0x08,0x00,
	0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,
	0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,
	0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,
	0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,
	0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,
	0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,
	0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,
	0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,
	0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,
	0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,
	0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,
	0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,
	0x16,0x5c,0x02,0x73,0x31,0x5d,0x0d,0x51,0x58,0xfe,0x64,0x6c,0x38,0x97,0x33,0xf0,
	0x66,0x77,0x4d,0x4d,0xec,0x38,0x55,0x85,0xed,0x2d,0xfe,0xbe,0x8e,0x01,0xee,0x76,
	0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,0x00,0x50,0xe0,0x05,0x41,0x6c,0x70,0x68,
	0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,0x00,0x70,0xf0,0x04,
	0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,
	0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,
	0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,0x9a,0xa9,0xe9,0xef,0x30,0xd3,0x6b,0x38,
	0x57,0x00,0x8f,0x59,0xbc,0x1e,0x23,0xcf,0xeb,0x53,0x4e,0x6c,0x64,0x8d,0x56,0x1d,
	0x5c,0x39,0x07,0xdc,0x13,0x4e,0x54,0x21,0x1b,0x6e,0x50,0xb5,0xec,0x60,0xe8,0x8a,
	0x4c,0xde,0x8b,0xf5,0xad,0x6c,0xd0,0x5b,0xfd,0xe8,0xd5,0x80,0xef,0x70,0x7e,0xe0,
	0x93,0xca,0xbd,0x03,0xeb,0x93,0xf4,0x82,0xeb,0x1a,0xf3,0xc7,0x8d,0xc6,0x17,0xa2,
	0x78,0x01,0x82,0x06,0x3e,0xdb,0x62,0x95,0x98,0x3a,0x1a,0x6c,0x23,0x34,0x99,0x0b,
	0x84,0x1c,0x24,0x20,0x3b,0xfd,0x6c,0x55,0x5a,0x8f,0x9c,0xdd,0x22,0xc2,0xc6,0x07,
	0x70,0xd0,0x02,0x71,0x65,0xff,0x7a,0xa5,0x5b,0x18,0xa4,0x39,0x59,0xcf,0x94,0x4d,
	0xf5,0xee,0xf0,0x47,0xe0,0x85,0xeb,0x13,0xd1,0x21,0x8d,0x15,0x32,0x76,0x01,0x1e,
	0x6f,0x9f,0xaf,0xc3,0x78,0x61,0xb7,0xf9,0x15,0xa1,0x18,0x4e,0x51,0x54,0x64,0x2b,
	0x68,0x7f,0xca,0x52,0x8f,0x34,0xd9,0x05,0xc8,0x64,0xc5,0xbe,0x48,0xab,0x0e,0x83,
	0x35,0xa1,0x13,0x2a,0xf2,0xc8,0x5e,0x53,0x3c,0x57,0x7a,0xf8,0x74,0xaf,0x03,0xaf,
	0x8d,0x58,0x9b,0xca,0xfa,0x65,0x0b,0x83,0x7d,0x0a,0x95,0x5a,0x77,0x94,0xce,0xee,
	0xc3,0x9e,0xab,0xf1,0x3e,0x9d,0xde,0x4b,0x3b,0x6e,0xed,0x1a,0x17,0xf5,0x88,0x34,
	0x18,0xcc,0xb8,0xb2,0x50,0xa1,0xb8,0xfc,0xff,0x89,0xe4,0xae,0x99,0xa3,0x56,0xa8,
	0x02,0x83,0x58,0x31,0xf4,0x90,0xa6,0x0e,0xa0,0x9a,0x4b,0x83,0xed,0x2b,0x6c,0x4f,
	0x28,0x92,0x23,0x98,0x64,0xc9,0x8f,0x9f
};

/**
 * Length of the testing PCD with no power controller.
 */
const uint32_t PCD_NO_POWER_CONTROLLER_DATA_LEN = sizeof (PCD_NO_POWER_CONTROLLER_DATA);

/**
 * PCD_NO_POWER_CONTROLLER_DATA hash for testing.
 */
const uint8_t PCD_NO_POWER_CONTROLLER_HASH[] = {
	0x6a,0x3e,0x91,0x2a,0x3d,0x8d,0x3e,0xbb,0x40,0x26,0x53,0xf3,0x7d,0x94,0xfd,0x4c,
	0x0c,0x0a,0x72,0xb3,0xdc,0x60,0xbc,0xc1,0x0d,0x80,0x81,0x26,0x97,0x62,0xe6,0x27
};

/**
 * The platform ID for the PCD with no power controller.
 */
const char PCD_NO_POWER_CONTROLLER_PLATFORM_ID[] = "SKU1";

/**
 * Components of the no power controller PCD.
 */
static struct pcd_testing_data PCD_NO_POWER_CONTROLLER_TESTING = {
	.manifest = {
		.raw = PCD_NO_POWER_CONTROLLER_DATA,
		.length = sizeof (PCD_NO_POWER_CONTROLLER_DATA),
		.hash = PCD_NO_POWER_CONTROLLER_HASH,
		.hash_len = sizeof (PCD_NO_POWER_CONTROLLER_HASH),
		.id = 0x1a,
		.signature = PCD_NO_POWER_CONTROLLER_DATA + (sizeof (PCD_NO_POWER_CONTROLLER_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_NO_POWER_CONTROLLER_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_NO_POWER_CONTROLLER_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x0114,
		.toc_hash = PCD_NO_POWER_CONTROLLER_DATA + 0x0100,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0100,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 6,
		.toc_hashes = 6,
		.plat_id = PCD_NO_POWER_CONTROLLER_DATA + 0x0120,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_NO_POWER_CONTROLLER_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_NO_POWER_CONTROLLER_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0120,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0150,
	.rot_entry = 3,
	.rot_hash = 3,
	.power_ctrl_len = 0,
	.power_ctrl_offset = 0,
	.power_ctrl_entry = -1,
	.power_ctrl_hash = -1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x013c,
	.bridge_component_entry = 2,
	.bridge_component_hash = 2,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x0128,
	.direct_component_entry = 1,
	.direct_component_hash = 1,
	.port_len = 0x0008,
	.port_offset = 0x0158,
	.port_entry = 4,
	.port_hash = 4,
	.num_optional_elements = 4,
};

/**
 * PCD with no components for testing.
 */
const uint8_t PCD_NO_COMPONENTS_DATA[] = {
	0x24,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x05,0x05,0x00,0x00,
	0x00,0xff,0x01,0x00,0xf8,0x00,0x08,0x00,0x42,0xff,0x01,0x01,0x00,0x01,0x0c,0x00,
	0x40,0xff,0x01,0x02,0x0c,0x01,0x08,0x00,0x41,0x40,0x01,0x03,0x14,0x01,0x08,0x00,
	0x41,0x40,0x01,0x04,0x1c,0x01,0x08,0x00,0x64,0x40,0x93,0x61,0xef,0x95,0x6e,0xd9,
	0x47,0xd0,0x56,0x1d,0x4c,0x48,0x57,0x8e,0x26,0xd4,0x7a,0xb2,0x4c,0x77,0x20,0x1b,
	0x2b,0x8f,0x67,0x27,0x87,0xad,0xf1,0x0d,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0xd2,0xa6,0x2d,0x1d,0x39,0xe8,0x56,
	0x55,0xef,0x0f,0x7b,0xc8,0xa2,0xc9,0x2e,0x79,0x00,0x47,0x06,0x16,0xbb,0xb5,0x26,
	0x47,0x15,0x3a,0x8e,0x4f,0xcb,0xd1,0x9f,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0xef,0x59,0x9c,0x91,0x93,0x97,0xcd,0xa7,
	0x8a,0x3d,0x85,0x56,0x78,0xac,0x24,0x1c,0x94,0x05,0xde,0xb8,0x2c,0x41,0xd1,0x7f,
	0x9c,0x20,0x15,0xf9,0x66,0x8b,0xa8,0x43,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x32,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x02,0x00,0x41,
	0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,0x01,0x04,0x01,0x0a,
	0x00,0x90,0xd0,0x03,0x4d,0x40,0xec,0x8b,0x9e,0xa4,0x1c,0xc9,0xbf,0x64,0x06,0x8a,
	0x2c,0xe1,0x76,0x77,0x30,0x14,0xcd,0xe1,0xfc,0x5a,0xda,0x6b,0xff,0x97,0x89,0xc8,
	0x0b,0x41,0x8c,0x46,0x45,0xf6,0xf9,0xe5,0xcd,0x44,0x02,0x97,0x43,0xdb,0x76,0x3c,
	0x22,0x81,0x7b,0x3e,0x42,0x6f,0xa0,0x1f,0xa0,0xf8,0x17,0x0c,0x3e,0xf3,0x25,0xd1,
	0x12,0x4e,0xe5,0x21,0xe5,0x2d,0xf5,0x8d,0xf5,0xfc,0xc6,0xfe,0x63,0x02,0x42,0xb6,
	0x85,0xbf,0x41,0x22,0xc1,0xfa,0x69,0xe0,0xe3,0x0c,0xab,0xbe,0x47,0x1b,0x4e,0xe9,
	0x89,0x7c,0xf9,0xd7,0x8c,0x5c,0x47,0x85,0xe7,0x10,0x4a,0x7c,0x91,0x42,0x95,0xe1,
	0xa6,0x32,0x5b,0xcf,0xc9,0x5a,0x4f,0x20,0xa3,0x15,0x11,0xed,0xd6,0xf6,0xa1,0x1c,
	0x55,0x68,0x2f,0x71,0x82,0x01,0x6a,0xc8,0xec,0x11,0xb8,0x6e,0x9b,0x2c,0x29,0xce,
	0x4b,0x93,0x12,0x4b,0x0d,0xb5,0x60,0xb1,0x1b,0xf1,0xbc,0xfa,0xbe,0x92,0x4c,0x7b,
	0xeb,0x98,0x53,0x5d,0x59,0xbb,0x89,0xed,0xc0,0x0a,0xad,0x82,0x37,0x81,0x39,0xdf,
	0x73,0xb7,0xb2,0x62,0x62,0x10,0x58,0x8e,0xbb,0x24,0xef,0x49,0xfc,0xd8,0xdf,0xab,
	0xba,0xf8,0x86,0x3e,0x51,0x95,0x87,0xd6,0xeb,0xea,0xc4,0x07,0x79,0xae,0xb5,0x99,
	0x48,0x19,0x37,0xca,0xc6,0x0c,0x31,0x40,0x29,0xc9,0xd3,0xaf,0xca,0xa4,0xca,0x53,
	0x02,0x35,0xc8,0xed,0x04,0xdc,0xfb,0x22,0xde,0x58,0x4f,0x24,0xb0,0xf0,0x0a,0x53,
	0xa7,0x0c,0xb4,0x60,0xbc,0xc9,0xcc,0xee,0x6e,0x68,0x28,0x5e,0x38,0xb6,0x67,0x54,
	0x70,0x4f,0xc6,0x1f
};

/**
 * Length of the testing PCD with no components.
 */
const uint32_t PCD_NO_COMPONENTS_DATA_LEN = sizeof (PCD_NO_COMPONENTS_DATA);

/**
 * PCD_NO_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_NO_COMPONENTS_HASH[] = {
	0x81,0x94,0x33,0x00,0x28,0xc3,0xeb,0xc2,0xae,0x90,0x0d,0x19,0x03,0x03,0x82,0x53,
	0xee,0xc4,0x57,0x4a,0xf8,0x64,0x88,0x17,0xb4,0x81,0x58,0x6e,0xf7,0x82,0xd6,0xf8
};

/**
 * The platform ID for the PCD with no components.
 */
const char PCD_NO_COMPONENTS_PLATFORM_ID[] = "SKU2";

/**
 * Components of the no components PCD.
 */
const struct pcd_testing_data PCD_NO_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_NO_COMPONENTS_DATA,
		.length = sizeof (PCD_NO_COMPONENTS_DATA),
		.hash = PCD_NO_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_NO_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_NO_COMPONENTS_DATA + (sizeof (PCD_NO_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_NO_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_NO_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x00ec,
		.toc_hash = PCD_NO_COMPONENTS_DATA + 0x00d8,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x00d8,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 5,
		.toc_hashes = 5,
		.plat_id = PCD_NO_COMPONENTS_DATA + 0x00f8,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_NO_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_NO_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x00f8,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x010c,
	.rot_entry = 2,
	.rot_hash = 2,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0100,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0,
	.bridge_component_offset = 0,
	.bridge_component_entry = -1,
	.bridge_component_hash = -1,
	.direct_component_len = 0,
	.direct_component_offset = 0,
	.direct_component_entry = -1,
	.direct_component_hash = -1,
	.port_len = 0x0008,
	.port_offset = 0x0114,
	.port_entry = 3,
	.port_hash = 3,
	.num_optional_elements = 3,
};

/**
 * PCD with no ports for testing.
 */
const uint8_t PCD_NO_PORTS_DATA[] = {
	0x3c,0x02,0x29,0x10,0x9b,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x05,0x05,0x00,0x00,
	0x00,0xff,0x01,0x00,0xf8,0x00,0x08,0x00,0x42,0xff,0x01,0x01,0x00,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x0c,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x20,0x01,0x14,0x00,
	0x40,0xff,0x01,0x04,0x34,0x01,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,
	0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,
	0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,
	0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,
	0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,0xd5,0xe0,0x5d,0x36,0xa4,0xb0,0x62,0xc7,
	0xb8,0x37,0x02,0x51,0x83,0x69,0xaa,0x81,0xb4,0xd4,0x94,0xe2,0x29,0x68,0x7f,0xf4,
	0xea,0x53,0x81,0x17,0x39,0x1e,0xb5,0x3d,0xcf,0x83,0x19,0x1b,0xb0,0x17,0x6b,0x8b,
	0xdb,0x86,0xe9,0xfc,0x5d,0x1c,0x91,0x62,0xaf,0xbe,0x9b,0xf4,0x74,0x2a,0x1b,0x90,
	0x9b,0x9c,0xb4,0x38,0x60,0xa9,0xa8,0xe1,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,
	0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,
	0x00,0x70,0xf0,0x04,0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,
	0x02,0x30,0x00,0x00,0x00,0x00,0x02,0x41,0x0b,0x10,0x0a,0x00,0x13,0x84,0x94,0x25,
	0x90,0xd6,0x7d,0x2f,0x47,0xba,0x04,0xaa,0x3a,0x67,0x46,0x25,0x22,0x4d,0x71,0xb0,
	0x8a,0x69,0x40,0x41,0x14,0xe7,0xd0,0x75,0x8e,0x60,0x19,0xde,0x8f,0xc4,0x3a,0xde,
	0x44,0x13,0x1d,0x31,0xbe,0xe4,0x85,0xf1,0xbd,0x8c,0xf6,0x52,0x66,0x78,0xaf,0x20,
	0x7d,0x82,0x90,0x6c,0xe3,0x0a,0x92,0xfb,0xa4,0x93,0x58,0x74,0x15,0xc8,0x15,0x74,
	0x9f,0x52,0x7e,0x79,0x74,0xab,0x50,0x80,0x83,0xd9,0x5e,0x6d,0x38,0x96,0xfb,0x0a,
	0xa5,0x53,0x0d,0x6b,0xe3,0x42,0xa1,0x8d,0x4f,0xd7,0x93,0xad,0xf7,0xbf,0x0d,0xdd,
	0x52,0xc0,0xbc,0x4e,0xef,0x48,0xa7,0x66,0xae,0x70,0x85,0x14,0x1a,0x08,0x7f,0x16,
	0x52,0x98,0x27,0x99,0xe9,0xf6,0x91,0xd0,0x23,0x9f,0x8b,0xcc,0x78,0x96,0xb4,0x8d,
	0x26,0x96,0xb6,0xaa,0x15,0xfd,0x67,0x35,0x3b,0xe1,0x78,0xbc,0x85,0x76,0x22,0x03,
	0x8c,0xda,0x08,0xb5,0x06,0x57,0x3c,0x93,0xb5,0x48,0x67,0xa6,0x17,0x15,0xf0,0x4e,
	0x26,0x70,0x4a,0xf6,0xd6,0x60,0xb2,0x83,0xd2,0x28,0x5b,0xbd,0xc3,0xae,0xee,0xf5,
	0x83,0x89,0x7f,0x64,0x84,0x27,0x0e,0x88,0xd1,0x27,0x08,0xb5,0xfb,0xe3,0x98,0x06,
	0x5d,0x9d,0x44,0x19,0x46,0xe4,0xab,0xa5,0x7e,0x35,0x5c,0x72,0x46,0x2f,0x32,0x30,
	0x5d,0x9a,0xc8,0xd7,0xb6,0x21,0xed,0x1e,0xbb,0x80,0xb7,0xf1,0xe5,0xb4,0x52,0xf3,
	0x4a,0x49,0x35,0xa7,0x36,0x45,0x0e,0x22,0x11,0xf4,0x41,0x29,0x4c,0x2b,0xc7,0xf4,
	0xae,0x73,0x69,0x5a,0x68,0xbd,0xf6,0xd6,0xe6,0xf6,0x55,0x73
};

/**
 * Length of the testing PCD with no ports.
 */
const uint32_t PCD_NO_PORTS_DATA_LEN = sizeof (PCD_NO_PORTS_DATA);

/**
 * PCD_NO_PORTS_DATA hash for testing.
 */
const uint8_t PCD_NO_PORTS_HASH[] = {
	0x76,0xa4,0x72,0x4d,0x43,0x4c,0x77,0x67,0xf5,0xd7,0xcc,0x4f,0xee,0x33,0xd4,0x9c,
	0xa8,0x73,0x40,0xdb,0x48,0x25,0x25,0x9c,0x02,0xc0,0x54,0x73,0x11,0xa3,0x85,0xc1
};

/**
 * The platform ID for the PCD with no ports.
 */
const char PCD_NO_PORTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the no ports PCD.
 */
const struct pcd_testing_data PCD_NO_PORTS_TESTING = {
	.manifest = {
		.raw = PCD_NO_PORTS_DATA,
		.length = sizeof (PCD_NO_PORTS_DATA),
		.hash = PCD_NO_PORTS_HASH,
		.hash_len = sizeof (PCD_NO_PORTS_HASH),
		.id = 0x1a,
		.signature = PCD_NO_PORTS_DATA + (sizeof (PCD_NO_PORTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_NO_PORTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_NO_PORTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x00ec,
		.toc_hash = PCD_NO_PORTS_DATA + 0x00d8,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x00d8,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 5,
		.toc_hashes = 5,
		.plat_id = PCD_NO_PORTS_DATA + 0x00f8,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_NO_PORTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_NO_PORTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x00f8,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0134,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0100,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x0120,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x010c,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0,
	.port_offset = 0,
	.port_entry = -1,
	.port_hash = -1,
	.num_optional_elements = 3,
};

/**
 * PCD with no ports, power controller, or components for testing.
 */
const uint8_t PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA[] = {
	0x90,0x01,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x02,0x00,0x00,
	0x00,0xff,0x01,0x00,0x80,0x00,0x08,0x00,0x40,0xff,0x01,0x01,0x88,0x00,0x08,0x00,
	0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,
	0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,
	0xe8,0x58,0xbc,0x23,0x93,0xad,0xe0,0xff,0x20,0xfb,0x2a,0x56,0x5b,0x22,0x85,0xef,
	0xb3,0x2c,0x62,0xf6,0x02,0xdc,0x54,0xf7,0x0f,0xd5,0xb8,0x07,0x2e,0x92,0xb1,0x4b,
	0x49,0xb5,0x50,0x25,0xed,0xb8,0xd0,0x9a,0xba,0xf3,0x32,0x36,0x58,0xd1,0xc3,0x69,
	0x95,0x0b,0x4b,0x88,0xc0,0x08,0xe5,0x5f,0x2a,0xd8,0xa8,0x88,0x1f,0xd8,0xe1,0x57,
	0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,0x00,0x00,0x00,0x41,0x0b,0x10,0x0a,0x00,
	0x5c,0x6b,0xbb,0xa8,0x0c,0x38,0x46,0x33,0x1d,0xfa,0x45,0x1f,0xb9,0x7c,0x58,0x1e,
	0xbb,0x44,0x32,0x45,0xb2,0x75,0x66,0x57,0xf6,0x82,0x80,0x8f,0x1a,0xa7,0x9b,0x2b,
	0xb0,0xd1,0xb2,0x10,0xf2,0x6a,0x01,0xc1,0xc3,0xbc,0xd9,0xe2,0x9d,0x29,0xcc,0xd7,
	0x05,0x89,0x9d,0xb4,0x2c,0x82,0x28,0x5e,0xf4,0xa1,0xff,0x6b,0xe0,0x79,0x0c,0x37,
	0x72,0x50,0x1b,0x02,0x01,0x4a,0x9b,0x94,0x73,0xb6,0xb5,0x1f,0xf0,0x6a,0xcd,0xa4,
	0xe1,0x04,0xab,0x7e,0x5c,0x23,0x66,0x40,0xb7,0x7c,0xe5,0xeb,0x8b,0xb4,0xf5,0x55,
	0x39,0xbe,0x4c,0x12,0x24,0xdd,0x56,0xc3,0x63,0xdf,0x07,0x27,0x1a,0xee,0xd8,0x1b,
	0xc1,0xeb,0x43,0xaa,0x1e,0xc9,0xb3,0x90,0x7d,0x72,0xce,0xdc,0xc6,0xb8,0xb6,0x3c,
	0x38,0xaf,0x8d,0x44,0xc4,0xa5,0x99,0x10,0xd4,0xc9,0x90,0xe0,0x8a,0xa7,0x1a,0x65,
	0xb2,0x08,0xa9,0xe0,0xd6,0xb0,0x06,0x51,0x0a,0xf1,0x65,0x33,0x46,0xff,0xe8,0x1c,
	0x5a,0x81,0xe9,0xc1,0xab,0xca,0xb5,0xb6,0x3b,0x48,0x6e,0xfe,0x1e,0x10,0xa9,0xdd,
	0x55,0xa0,0x72,0x2a,0x52,0xbd,0xfb,0xb1,0x69,0xee,0xb0,0xa2,0xf6,0x29,0xa9,0xb2,
	0xa3,0x1e,0xe0,0xef,0xee,0x68,0xbd,0x1c,0x28,0x28,0x69,0x78,0xb0,0x2e,0xdc,0x80,
	0xe2,0xfe,0xf1,0xe7,0x5f,0x38,0x84,0x5d,0x3a,0xb3,0xa3,0x9b,0xaa,0x6c,0x26,0x55,
	0xd9,0x51,0x98,0xb9,0xad,0x0e,0xc3,0xb8,0xe8,0x37,0xcd,0xdd,0x03,0x23,0x00,0x87,
	0x27,0xc5,0x70,0xb1,0x9f,0xa4,0x0d,0x45,0x00,0xc9,0x48,0x0c,0xd0,0xd5,0xff,0xe9
};

/**
 * Length of the testing PCD with no ports, power controller, nor components.
 */
const uint32_t PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA_LEN =
	sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA);

/**
 * PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_HASH[] = {
	0x58,0x5e,0xbe,0xb4,0x18,0xf1,0x1d,0x68,0x55,0x5e,0xae,0x6f,0xe4,0xda,0xef,0xd6,
	0x76,0x19,0x57,0xd9,0xda,0x8d,0x0a,0x4c,0xe9,0x45,0x56,0xf4,0x48,0x35,0x19,0x0d
};

/**
 * The platform ID for the PCD with no ports, power controller, nor components.
 */
const char PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the no components PCD.
 */
static struct pcd_testing_data PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA,
		.length = sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA),
		.hash = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA +
			(sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x0074,
		.toc_hash = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA + 0x0060,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0060,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 2,
		.toc_hashes = 2,
		.plat_id = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_DATA + 0x0080,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0080,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0088,
	.rot_entry = 1,
	.rot_hash = 1,
	.power_ctrl_len = 0,
	.power_ctrl_offset = 0,
	.power_ctrl_entry = -1,
	.power_ctrl_hash = -1,
	.bridge_component_len = 0,
	.bridge_component_offset = 0,
	.bridge_component_entry = -1,
	.bridge_component_hash = -1,
	.direct_component_len = 0,
	.direct_component_offset = 0,
	.direct_component_entry = -1,
	.direct_component_hash = -1,
	.port_len = 0,
	.port_offset = 0,
	.port_entry = -1,
	.port_hash = -1,
	.num_optional_elements = 0,
};

/**
 * PCD with only direct components for testing.
 */
const uint8_t PCD_ONLY_DIRECT_COMPONENTS_DATA[] = {
	0x98,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x50,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x5c,0x01,0x14,0x00,0x43,0xff,0x01,0x03,0x70,0x01,0x10,0x00,
	0x40,0xff,0x01,0x04,0x80,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x88,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0x90,0x01,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,
	0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,
	0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,0x9c,0x99,0x85,0x04,0xfc,0x3c,0xf3,0xaf,
	0xf7,0x1c,0x77,0x3b,0xe3,0xff,0x7e,0x66,0x67,0x52,0x03,0x2d,0x55,0x5b,0xf1,0x52,
	0x8a,0xf8,0xec,0xb6,0x12,0xf5,0x89,0xcc,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0x99,0x2a,0x75,0x4e,0x1c,0x69,0x83,0xab,
	0x95,0x91,0x75,0xc3,0x64,0x25,0x29,0x07,0x0e,0xee,0x09,0x03,0xa4,0x81,0x51,0xcf,
	0xaf,0x37,0x12,0x54,0x52,0x39,0xe2,0xd6,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,
	0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,
	0x00,0x56,0xe6,0x04,0x42,0x65,0x74,0x61,0x11,0x05,0x81,0x88,0x11,0x04,0x00,0x00,
	0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,
	0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,0xc2,0x1d,0x8b,0x20,0x95,0x17,0xf5,0x92,
	0x8c,0xdd,0x59,0x1f,0x06,0xde,0x6d,0x4c,0x3f,0xa0,0x00,0x60,0x22,0x31,0xc6,0x44,
	0xb4,0xfe,0x9c,0xbe,0xbb,0xe7,0x80,0x01,0x14,0x83,0x50,0xaf,0x12,0x78,0xbe,0xc0,
	0xb2,0xdd,0x19,0x5c,0x5d,0x72,0x9c,0xda,0x64,0x60,0xa1,0x51,0x64,0x8b,0x1d,0xc4,
	0x0d,0x4c,0x03,0x7b,0xfa,0x8e,0x3e,0x27,0x00,0xcb,0x3a,0x9f,0x91,0x87,0xfa,0x71,
	0x26,0xd4,0xee,0xdf,0x8a,0x8f,0x36,0xa7,0xc3,0xfa,0x17,0x62,0x25,0xd5,0x88,0x8c,
	0x6d,0x7b,0xcd,0x88,0x8f,0x69,0x1f,0xd6,0x6b,0x0b,0x1c,0x04,0x37,0xe0,0xdf,0x9d,
	0x74,0x5b,0xcf,0xbe,0x97,0x7c,0xd3,0x59,0xee,0xf7,0xe7,0x20,0x80,0x8a,0x18,0x38,
	0xf8,0xe2,0xd8,0x7b,0x76,0x44,0xd6,0x48,0xb2,0xac,0x0d,0x2c,0x5c,0x24,0x93,0xdb,
	0xdf,0x37,0x8a,0xfc,0x89,0x56,0x89,0x76,0x69,0x86,0x37,0x1b,0xb8,0xe8,0x0b,0x51,
	0x06,0x56,0xe3,0x80,0xdb,0x13,0xa5,0x26,0x16,0x5b,0x2f,0xa0,0xf5,0xea,0x2d,0x04,
	0xc7,0x29,0x1c,0xa8,0xe6,0x74,0x35,0xaa,0xce,0xc7,0xfd,0x80,0x9f,0x66,0x9c,0xc1,
	0xcd,0x35,0x36,0x7d,0x16,0xff,0x55,0xe0,0x5c,0xd3,0x23,0x02,0x5d,0xaa,0xc3,0xdb,
	0x73,0x53,0xa9,0x30,0x3f,0x4f,0xff,0x12,0x20,0xf3,0xde,0x53,0x50,0x88,0x4d,0xb4,
	0x3b,0x8d,0x96,0x70,0x41,0x23,0xc4,0x4f,0x23,0xeb,0x16,0xd7,0xa4,0x70,0xdf,0xcf,
	0x79,0x98,0x1f,0xbf,0x09,0x67,0xb2,0xc1,0x40,0xd6,0xc2,0xa2,0xad,0xa6,0x3c,0x65,
	0x88,0x1f,0xfe,0xa3,0x57,0x4b,0xba,0xec
};

/**
 * Length of the testing PCD with only direct components.
 */
const uint32_t PCD_ONLY_DIRECT_COMPONENTS_DATA_LEN = sizeof (PCD_ONLY_DIRECT_COMPONENTS_DATA);

/**
 * PCD_ONLY_DIRECT_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_ONLY_DIRECT_COMPONENTS_HASH[] = {
	0x70,0xa2,0x25,0x5c,0x46,0xc6,0x74,0x79,0xa1,0x27,0xa1,0x74,0xd6,0x1d,0xe3,0xd7,
	0x5f,0x4a,0x79,0x31,0xcf,0x28,0x4e,0x14,0xde,0x8d,0x80,0x42,0xe9,0xa6,0x2a,0x81
};

/**
 * The platform ID for the PCD with only direct components.
 */
const char PCD_ONLY_DIRECT_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with only direct components.
 */
const struct pcd_testing_data PCD_ONLY_DIRECT_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_ONLY_DIRECT_COMPONENTS_DATA,
		.length = sizeof (PCD_ONLY_DIRECT_COMPONENTS_DATA),
		.hash = PCD_ONLY_DIRECT_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_ONLY_DIRECT_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_ONLY_DIRECT_COMPONENTS_DATA +
			(sizeof (PCD_ONLY_DIRECT_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_ONLY_DIRECT_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_ONLY_DIRECT_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_ONLY_DIRECT_COMPONENTS_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_ONLY_DIRECT_COMPONENTS_DATA + 0x0148,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_ONLY_DIRECT_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_ONLY_DIRECT_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0180,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0150,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0,
	.bridge_component_offset = 0,
	.bridge_component_entry = -1,
	.bridge_component_hash = -1,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x015c,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x0188,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * PCD with multiple direct components for testing.
 */
const uint8_t PCD_MULTIPLE_DIRECT_COMPONENTS_DATA[] = {
	0xd8,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x08,0x08,0x00,0x00,
	0x00,0xff,0x01,0x00,0x70,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x78,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x84,0x01,0x14,0x00,0x43,0xff,0x01,0x03,0x98,0x01,0x14,0x00,
	0x44,0xff,0x01,0x04,0xac,0x01,0x14,0x00,0x40,0xff,0x01,0x05,0xc0,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0xc8,0x01,0x08,0x00,0x41,0x40,0x01,0x07,0xd0,0x01,0x08,0x00,
	0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,
	0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,
	0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,
	0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,
	0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,
	0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,
	0xce,0xcd,0x24,0x58,0x55,0x35,0xe0,0x6a,0x38,0xe2,0xaf,0x4f,0x2a,0xfd,0x23,0x2c,
	0x8b,0xc7,0x5e,0x3b,0x5f,0x11,0x3b,0x4b,0xac,0xa5,0x8d,0x41,0xe0,0x7a,0x84,0x1f,
	0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,
	0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,
	0xd0,0xbe,0x88,0x74,0x17,0xab,0x74,0xf0,0xb6,0x62,0x8a,0x50,0x33,0x51,0x40,0x0c,
	0xd1,0xab,0x2b,0xd6,0x47,0x87,0x24,0x18,0x91,0xd8,0xc9,0xc5,0x60,0x8b,0x19,0xa2,
	0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,
	0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,
	0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,
	0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,
	0x65,0xa3,0x93,0xb1,0x33,0xc9,0xef,0x69,0x46,0x71,0x88,0x42,0x82,0xce,0xbf,0xc2,
	0xb8,0xeb,0x16,0x85,0x44,0x54,0xa1,0x3c,0x8e,0xe5,0x5d,0xb5,0xc3,0x9b,0xfb,0x01,
	0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,
	0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,
	0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,0x00,0x56,0xe6,0x05,0x54,0x68,0x65,0x74,
	0x61,0x00,0x00,0x00,0x11,0x05,0x81,0x88,0x11,0x04,0x00,0x00,0x00,0x70,0xf0,0x04,
	0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,
	0x00,0x02,0x03,0x41,0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,
	0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,0x5f,0x3a,0xd8,0x82,0xb9,0x7f,0xff,0xa8,
	0xab,0xc9,0xa7,0x73,0xaf,0x12,0x8d,0x65,0xad,0x66,0x3a,0xcd,0xef,0x84,0x85,0xd6,
	0x69,0xa5,0xda,0x85,0xd5,0x55,0x6b,0x21,0x74,0x54,0x36,0xd1,0xc2,0x3a,0x4c,0xc9,
	0x33,0xa7,0x55,0xf7,0xb4,0x8c,0x3f,0x5e,0x06,0x63,0x6b,0x28,0x52,0xf5,0x7a,0x0b,
	0x41,0x74,0xf0,0xae,0xc2,0xc2,0x71,0xe5,0x85,0x44,0x51,0x02,0xc9,0x2a,0xd4,0xb2,
	0xc3,0x01,0x4b,0x0c,0xf7,0x48,0x89,0x05,0xdb,0x24,0xa6,0xf2,0x8d,0x1b,0x5a,0xc9,
	0x2d,0xb8,0xac,0xad,0x6b,0xb0,0xab,0xba,0xf6,0x0f,0xae,0x60,0x02,0xee,0x75,0xca,
	0x95,0xb3,0x01,0xc6,0x4f,0xb4,0x5b,0x17,0x23,0xc7,0xf1,0x94,0x8c,0x26,0xfc,0x4c,
	0x0d,0xf5,0xb3,0xbd,0xf0,0x71,0xdc,0x37,0xbe,0x4a,0xf3,0xf3,0x7b,0x6b,0x7f,0x39,
	0x34,0x03,0xa7,0xd0,0x54,0x93,0x7c,0x42,0x9e,0xa0,0x70,0xb1,0xdb,0x34,0x5b,0x24,
	0x0e,0x3f,0xa6,0x2a,0x94,0x65,0x87,0x64,0xa6,0x6d,0xd2,0x7a,0x40,0xdb,0x92,0x86,
	0xcf,0x58,0x71,0x8b,0xfd,0xfe,0x70,0x0c,0xea,0x5a,0x2a,0x72,0xe6,0x7f,0x08,0x11,
	0xd9,0x22,0xc3,0x56,0x85,0x81,0xa7,0x74,0xfa,0x3e,0xac,0x23,0xec,0x03,0x68,0xd7,
	0x26,0xa9,0x70,0xff,0x30,0xae,0x3e,0x43,0x05,0x87,0xbb,0xf1,0xfe,0x0c,0x30,0xb1,
	0xb6,0xa4,0x88,0x8b,0x58,0xd2,0x6f,0xf0,0x6c,0xa4,0xce,0xd7,0x7c,0x7f,0xd3,0x2a,
	0x67,0x8b,0xbf,0x47,0x59,0xd6,0xed,0x1b,0x22,0x40,0xba,0xb4,0x2b,0xe6,0x58,0x35,
	0xd1,0x4c,0x16,0x90,0x79,0xe5,0xc1,0x4d
};

/**
 * Length of the testing PCD with multiple direct components.
 */
const uint32_t PCD_MULTIPLE_DIRECT_COMPONENTS_DATA_LEN =
	sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_DATA);

/**
 * PCD_MULTIPLE_DIRECT_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_MULTIPLE_DIRECT_COMPONENTS_HASH[] = {
	0x82,0xef,0xce,0x60,0x6a,0x9d,0x97,0x40,0x9b,0x78,0x7b,0x82,0xed,0x1b,0x9d,0xcb,
	0x44,0x57,0x22,0xb9,0x34,0xe9,0xe3,0x1a,0x18,0xf2,0xd6,0x35,0xa8,0x68,0x99,0x5e
};

/**
 * The platform ID for the PCD with multiple direct components.
 */
const char PCD_MULTIPLE_DIRECT_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with multiple direct components.
 */
const struct pcd_testing_data PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_MULTIPLE_DIRECT_COMPONENTS_DATA,
		.length = sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_DATA),
		.hash = PCD_MULTIPLE_DIRECT_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_MULTIPLE_DIRECT_COMPONENTS_DATA +
			(sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_MULTIPLE_DIRECT_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x0164,
		.toc_hash = PCD_MULTIPLE_DIRECT_COMPONENTS_DATA + 0x0150,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0150,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 8,
		.toc_hashes = 8,
		.plat_id = PCD_MULTIPLE_DIRECT_COMPONENTS_DATA + 0x0170,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_MULTIPLE_DIRECT_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_MULTIPLE_DIRECT_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0170,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x01c0,
	.rot_entry = 5,
	.rot_hash = 5,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0178,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x01ac,
	.bridge_component_entry = 4,
	.bridge_component_hash = 4,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x0184,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x01c8,
	.port_entry = 6,
	.port_hash = 6,
	.num_optional_elements = 6,
};

/**
 * PCD with only bridge components for testing.
 */
const uint8_t PCD_ONLY_BRIDGE_COMPONENTS_DATA[] = {
	0xa0,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x50,0x01,0x0c,0x00,
	0x44,0xff,0x01,0x02,0x5c,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x70,0x01,0x18,0x00,
	0x40,0xff,0x01,0x04,0x88,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x90,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0x98,0x01,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,
	0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,
	0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,0x39,0x76,0xe3,0xaa,0xf6,0xab,0x74,0x2a,
	0x5c,0xbf,0xd0,0xdd,0x3a,0x10,0x59,0x7b,0x43,0x40,0xc5,0x82,0x5a,0x75,0xfe,0xfb,
	0x36,0xb0,0x50,0xb1,0xa7,0xec,0x95,0x87,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0xee,0x72,0x52,0xa3,0xd2,0xf2,0x01,0xcf,
	0xd3,0x07,0x75,0x8f,0x42,0x1c,0xb0,0x97,0x64,0x3a,0xab,0x94,0x8b,0xbb,0xbc,0x70,
	0x92,0x4f,0x18,0x31,0x4c,0x65,0x25,0xac,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x70,0xf0,0x04,
	0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,
	0x01,0x71,0xf1,0x05,0x54,0x68,0x65,0x74,0x61,0x00,0x00,0x00,0x0d,0x00,0x0e,0x00,
	0x0f,0x00,0x0a,0x00,0x01,0x35,0x00,0x00,0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,
	0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,
	0x61,0x92,0x15,0xec,0x73,0xb3,0x85,0xe8,0xa6,0x4a,0x00,0x42,0x55,0x25,0x04,0xe3,
	0x57,0x61,0x42,0x18,0x11,0x5d,0x6e,0x17,0xfb,0x10,0x8e,0x8f,0x61,0x3c,0x18,0x93,
	0x25,0xda,0x9f,0x3a,0xef,0xdd,0xbe,0xb0,0x70,0x79,0x7f,0xd3,0x00,0x5a,0x8e,0xf6,
	0x02,0xd2,0x77,0xee,0x03,0x45,0x11,0xbd,0xd7,0x14,0x28,0x1b,0x95,0x58,0x25,0x23,
	0xfc,0x6e,0xe0,0x3c,0x98,0x69,0xa7,0x85,0x57,0x6d,0x65,0x47,0x8e,0xaa,0x52,0xae,
	0xd9,0x4d,0x0b,0x59,0x50,0xa0,0xc9,0x90,0xf3,0x71,0xd9,0xc6,0x9e,0x94,0x2b,0xdb,
	0x70,0xfe,0xd5,0xe9,0x64,0xbb,0xfe,0xf4,0xf1,0x01,0xca,0xc2,0x35,0xf1,0xd1,0x97,
	0xa1,0x45,0x70,0xab,0xc6,0x8b,0x3a,0x85,0xa1,0x7c,0x81,0x4a,0x7d,0x42,0x4c,0xb2,
	0x4c,0xcf,0x9a,0xc4,0x10,0x2e,0xdd,0x30,0x67,0x67,0xc7,0x25,0xd7,0x9d,0x3b,0x72,
	0xfc,0x77,0x61,0xa8,0x7d,0x7f,0x9b,0x4f,0x91,0x26,0xd5,0x87,0xa6,0x5a,0xdb,0x4b,
	0x50,0x5e,0x38,0x17,0x25,0xdf,0x63,0xf0,0x80,0x46,0x72,0xa1,0x8e,0xfc,0x57,0x16,
	0x38,0xb7,0x42,0x80,0x59,0xba,0x62,0x8d,0x76,0x09,0x67,0xdd,0xd7,0xbb,0xbb,0x0c,
	0x1f,0x0a,0x5b,0x96,0x28,0xf1,0x67,0x50,0xb9,0x41,0x37,0xbe,0xa6,0x4e,0xba,0x47,
	0x86,0xe4,0x17,0xc2,0x5c,0xa5,0x89,0x47,0x63,0x8c,0xf4,0xe8,0x09,0xd9,0x39,0x5d,
	0xeb,0x09,0xe2,0xdf,0xd0,0x8b,0x96,0x4e,0x11,0x4c,0x91,0x3c,0xa0,0x28,0x82,0x44,
	0x0f,0x85,0xa6,0x47,0x85,0xcc,0xae,0xfa,0x96,0x6d,0x54,0xfa,0x83,0x7a,0x37,0xb1
};

/**
 * Length of the testing PCD with only bridge components.
 */
const uint32_t PCD_ONLY_BRIDGE_COMPONENTS_DATA_LEN = sizeof (PCD_ONLY_BRIDGE_COMPONENTS_DATA);

/**
 * PCD_ONLY_BRIDGE_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_ONLY_BRIDGE_COMPONENTS_HASH[] = {
	0x8b,0x4c,0xa4,0x14,0x00,0xfd,0x66,0xad,0xb0,0xd9,0xb2,0xe9,0x0a,0xea,0x72,0xc8,
	0x04,0x17,0xb8,0x73,0xe4,0x70,0xf3,0x77,0x01,0xdd,0x71,0x1d,0xf7,0x9e,0x4c,0x26
};

/**
 * The platform ID for the PCD with only bridge components.
 */
const char PCD_ONLY_BRIDGE_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with only bridge components.
 */
const struct pcd_testing_data PCD_ONLY_BRIDGE_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_ONLY_BRIDGE_COMPONENTS_DATA,
		.length = sizeof (PCD_ONLY_BRIDGE_COMPONENTS_DATA),
		.hash = PCD_ONLY_BRIDGE_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_ONLY_BRIDGE_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_ONLY_BRIDGE_COMPONENTS_DATA +
			(sizeof (PCD_ONLY_BRIDGE_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_ONLY_BRIDGE_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_ONLY_BRIDGE_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_ONLY_BRIDGE_COMPONENTS_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_ONLY_BRIDGE_COMPONENTS_DATA + 0x0148,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_ONLY_BRIDGE_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_ONLY_BRIDGE_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0188,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0150,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x015c,
	.bridge_component_entry = 2,
	.bridge_component_hash = 2,
	.direct_component_len = 0,
	.direct_component_offset = 0,
	.direct_component_entry = -1,
	.direct_component_hash = -1,
	.port_len = 0x0008,
	.port_offset = 0x0190,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * PCD with multiple bridge components for testing.
 */
const uint8_t PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA[] = {
	0xdc,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x08,0x08,0x00,0x00,
	0x00,0xff,0x01,0x00,0x70,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x78,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x84,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x98,0x01,0x14,0x00,
	0x44,0xff,0x01,0x04,0xac,0x01,0x18,0x00,0x40,0xff,0x01,0x05,0xc4,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0xcc,0x01,0x08,0x00,0x41,0x40,0x01,0x07,0xd4,0x01,0x08,0x00,
	0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,
	0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,
	0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,
	0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,
	0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,
	0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,
	0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,
	0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,
	0x39,0x76,0xe3,0xaa,0xf6,0xab,0x74,0x2a,0x5c,0xbf,0xd0,0xdd,0x3a,0x10,0x59,0x7b,
	0x43,0x40,0xc5,0x82,0x5a,0x75,0xfe,0xfb,0x36,0xb0,0x50,0xb1,0xa7,0xec,0x95,0x87,
	0xd0,0xbe,0x88,0x74,0x17,0xab,0x74,0xf0,0xb6,0x62,0x8a,0x50,0x33,0x51,0x40,0x0c,
	0xd1,0xab,0x2b,0xd6,0x47,0x87,0x24,0x18,0x91,0xd8,0xc9,0xc5,0x60,0x8b,0x19,0xa2,
	0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,
	0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,
	0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,
	0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,
	0xd1,0xf8,0x57,0xca,0x2d,0xbb,0x25,0x9c,0xda,0x3b,0x58,0xcd,0xc7,0x2b,0x1d,0xc1,
	0x93,0x8f,0x03,0xf7,0x14,0x3e,0xb3,0xc6,0xbc,0x13,0x04,0x03,0xab,0xdd,0x85,0xd0,
	0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,
	0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,
	0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,0x00,0x70,0xf0,0x04,0x42,0x65,0x74,0x61,
	0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,0x01,0x71,0xf1,0x05,
	0x54,0x68,0x65,0x74,0x61,0x00,0x00,0x00,0x0d,0x00,0x0e,0x00,0x0f,0x00,0x0a,0x00,
	0x01,0x35,0x00,0x00,0x00,0x02,0x03,0x41,0x0b,0x10,0x0a,0x00,0x00,0x31,0x00,0x00,
	0x00,0x48,0xe8,0x01,0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,0x09,0x5b,0x4d,0xc0,
	0x7d,0x7d,0xf2,0x59,0xfc,0xe9,0x4a,0xae,0x02,0x19,0x35,0xa7,0xc4,0xf5,0x12,0xc2,
	0x90,0x42,0x90,0xad,0xac,0x8b,0x08,0x9e,0x0e,0xd4,0x78,0xba,0xd0,0x7c,0x6b,0x23,
	0x80,0xf0,0x8e,0x98,0xe5,0x53,0xf4,0x36,0x20,0xe9,0x34,0xf9,0xe3,0xe4,0xaa,0xba,
	0x25,0x8b,0xf9,0x8b,0xfe,0x30,0x15,0x5e,0xcb,0x77,0xbb,0x9b,0x51,0x87,0xa1,0xb3,
	0x4a,0x6d,0x38,0xed,0x40,0xd6,0x76,0x02,0xc7,0x72,0xa1,0xb2,0x38,0xed,0xdf,0xe4,
	0x3c,0x86,0x43,0xfb,0xff,0x4b,0x38,0x9d,0xc9,0x1f,0x9f,0xae,0x79,0x1a,0x8e,0x3d,
	0x00,0x36,0x9f,0x79,0xed,0x9f,0x4c,0x63,0x94,0x2b,0x87,0x65,0x09,0xca,0x5f,0x8c,
	0x2c,0x47,0x41,0x59,0xc7,0x1b,0x64,0x63,0x17,0x42,0x80,0x59,0xde,0x64,0xdd,0x3e,
	0x6a,0xe9,0x11,0x4b,0xfa,0xe2,0x9b,0x32,0x93,0x1a,0xd9,0xa6,0x20,0x81,0x0c,0x5b,
	0xf0,0x72,0x5f,0xf2,0xa6,0x76,0x78,0x8e,0x61,0x58,0xdb,0x0b,0x1c,0x1e,0x3c,0x18,
	0x94,0x53,0xde,0xaf,0xe9,0xda,0x06,0x01,0xdc,0xdd,0xa6,0x65,0xdd,0x1d,0x46,0xb5,
	0x9c,0x8a,0x25,0xde,0x9e,0xb4,0x61,0x74,0xe0,0x8d,0xc9,0x90,0xc7,0x6a,0x8e,0x41,
	0x67,0xd6,0xa1,0x97,0xad,0xe0,0xf5,0x21,0x63,0x8a,0x05,0x56,0xf9,0xee,0xab,0xf1,
	0x0a,0x89,0x3e,0xc8,0xa8,0xcc,0xc8,0xfb,0x74,0xe2,0x7a,0x04,0x25,0xc3,0x45,0x9f,
	0xa4,0xcf,0xa1,0xf3,0xa8,0xea,0x20,0x3c,0xd3,0x9b,0xad,0xf3,0x0f,0x18,0x38,0xdc,
	0xe7,0x61,0xdf,0xbf,0xd3,0x21,0x4f,0xfe,0x0a,0xa1,0x59,0x97
};

/**
 * Length of the testing PCD with multiple bridge components.
 */
const uint32_t PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA_LEN =
	sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA);

/**
 * PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_MULTIPLE_BRIDGE_COMPONENTS_HASH[] = {
	0x34,0x26,0xf1,0xe8,0x61,0xfc,0x9e,0x45,0x72,0xf2,0x1b,0x3d,0xd8,0xae,0xd3,0xab,
	0xc5,0x61,0x3c,0xfe,0xb4,0x7f,0x4a,0x7f,0x4a,0x25,0x03,0x24,0x39,0x50,0xcd,0x4e
};

/**
 * The platform ID for the PCD with multiple bridge components.
 */
const char PCD_MULTIPLE_BRIDGE_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with multiple bridge components.
 */
const struct pcd_testing_data PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA,
		.length = sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA),
		.hash = PCD_MULTIPLE_BRIDGE_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA +
			(sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x0164,
		.toc_hash = PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA + 0x0150,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0150,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 8,
		.toc_hashes = 8,
		.plat_id = PCD_MULTIPLE_BRIDGE_COMPONENTS_DATA + 0x0170,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_MULTIPLE_BRIDGE_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_MULTIPLE_BRIDGE_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0170,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x01c4,
	.rot_entry = 5,
	.rot_hash = 5,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0178,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x0198,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x0184,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x01cc,
	.port_entry = 6,
	.port_hash = 6,
	.num_optional_elements = 6,
};

/**
 * PCD with components with maximum length type fields for testing.
 */
const uint8_t PCD_MAX_LEN_COMPONENTS_DATA[] = {
	0x90,0x04,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x50,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x5c,0x01,0x0c,0x01,0x44,0xff,0x01,0x03,0x68,0x02,0x10,0x01,
	0x40,0xff,0x01,0x04,0x78,0x03,0x08,0x00,0x41,0x40,0x01,0x05,0x80,0x03,0x08,0x00,
	0x41,0x40,0x01,0x06,0x88,0x03,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0xc4,0x11,0xa9,0xaa,0xa8,0xc1,0x92,0x5b,
	0x5d,0x99,0x1e,0x00,0x96,0xc2,0x02,0x6a,0x4b,0xdc,0x61,0xfe,0x9a,0x26,0xf8,0x9c,
	0xf1,0x08,0xb1,0xef,0x86,0xe9,0xdd,0x6d,0xbb,0x6d,0x47,0x0c,0x88,0xfb,0x2f,0x0b,
	0x11,0x95,0x84,0xba,0x3f,0x4b,0xa9,0x8a,0x0f,0x4e,0x82,0x18,0xf8,0xae,0xd9,0x19,
	0x3a,0x76,0xfc,0x7e,0x50,0x4d,0xfe,0x5f,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0xd8,0xa8,0xa9,0xa2,0x83,0xe3,0x96,0x44,
	0x4f,0xe0,0x88,0x64,0x32,0x82,0xd2,0x36,0xd9,0xac,0x81,0x15,0x30,0x9d,0x10,0x51,
	0xc9,0x73,0x14,0xa7,0xc1,0x85,0xeb,0x2b,0x1a,0x12,0xc0,0x2d,0x58,0x70,0x5e,0x4c,
	0xc1,0x0a,0x6f,0xff,0x25,0x23,0x1b,0x60,0x26,0x11,0x30,0xc1,0x83,0xf3,0x08,0x24,
	0xdb,0x1b,0x97,0x6a,0xcd,0xc5,0xde,0xa5,0xd8,0xfc,0xc3,0x66,0x45,0x3b,0xa5,0x9f,
	0xbb,0x47,0x41,0x56,0xe7,0xd3,0x10,0xce,0x7f,0xc7,0xef,0x99,0x77,0x29,0x3c,0x67,
	0xbe,0x8e,0x52,0x33,0x94,0xe6,0xde,0x7e,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0xff,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
	0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x00,
	0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,0x00,0x70,0xf0,0xff,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
	0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x00,0x0a,0x00,0x0b,0x00,
	0x0c,0x00,0x0d,0x00,0x02,0x30,0x00,0x00,0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,
	0x00,0x31,0x00,0x00,0x00,0x48,0xe8,0x01,0x01,0x04,0x01,0x0a,0x00,0x90,0xd0,0x03,
	0x8d,0xf7,0xa7,0x0b,0xec,0x32,0x90,0xf9,0x14,0x3a,0x93,0x44,0x2d,0x19,0x62,0x4d,
	0x19,0xe6,0x33,0x65,0xf0,0xc6,0xaf,0x9b,0x7c,0x15,0x24,0x07,0x9f,0x84,0x28,0x9b,
	0xce,0x93,0xaf,0x04,0xac,0xd3,0x99,0x59,0x1e,0xf5,0xc4,0x90,0xb2,0xad,0xfd,0x24,
	0x01,0x12,0xae,0xf9,0xc6,0xbe,0x41,0xb6,0x6f,0xd2,0x60,0xb0,0xca,0xd3,0x59,0x45,
	0x90,0x3b,0xe6,0x15,0xf1,0x68,0x99,0x20,0xc8,0xc4,0x33,0x16,0xc9,0x5d,0x10,0xd7,
	0xd7,0x07,0xd4,0x57,0x23,0x03,0x3d,0x43,0x82,0xa5,0x99,0xd6,0x23,0xfb,0x53,0x3e,
	0x72,0x11,0x1a,0x8d,0xdd,0x94,0x71,0xcc,0x05,0xc6,0x15,0x25,0xad,0xea,0x1c,0xe0,
	0xd4,0xe0,0xb4,0x58,0xb7,0x26,0x7c,0x7f,0x57,0xa7,0xaf,0xf2,0x1b,0x18,0x7b,0x9c,
	0x59,0x9a,0x90,0x4f,0x01,0x87,0x4f,0x97,0x35,0x19,0x71,0x6d,0x6d,0xe1,0x64,0xb0,
	0xbb,0x36,0xfc,0xf0,0xb0,0xbd,0xdc,0x2c,0x70,0x8a,0x93,0x10,0xd0,0x69,0x0d,0x88,
	0xd8,0xf1,0x31,0xd2,0x30,0x9d,0x7a,0xd6,0x34,0xe4,0x7f,0xc7,0x66,0x96,0x3d,0xcd,
	0x9a,0xea,0xbc,0x46,0xe9,0x9f,0x01,0xbe,0x6a,0x28,0xf0,0xec,0xff,0x53,0x80,0x32,
	0x2d,0xb5,0x20,0x1e,0x41,0x09,0xa3,0x0e,0x82,0x75,0x0b,0xdd,0x67,0xdd,0xa0,0xb9,
	0x1f,0x9b,0x6d,0xef,0x0d,0x0b,0xe0,0x85,0xa2,0xd7,0x6e,0x4e,0x04,0x24,0x86,0x3a,
	0x44,0x88,0xc6,0x87,0x23,0xc6,0x25,0xa9,0xd1,0x4a,0xf2,0x44,0x4a,0x9b,0x45,0x1f,
	0xfa,0x6d,0x9a,0x94,0x2a,0xa1,0x58,0x82,0x73,0xdd,0x3e,0x92,0xdb,0xd5,0x29,0x09
};

/**
 * Length of the testing PCD with components with maximum length type fields.
 */
const uint32_t PCD_MAX_LEN_COMPONENTS_DATA_LEN = sizeof (PCD_MAX_LEN_COMPONENTS_DATA);

/**
 * PCD_MAX_LEN_COMPONENTS_DATA hash for testing.
 */
const uint8_t PCD_MAX_LEN_COMPONENTS_HASH[] = {
	0x5b,0x98,0x78,0x39,0x20,0x56,0x76,0x3a,0xd8,0xf3,0x0e,0xe1,0x7f,0x9e,0x60,0xd2,
	0xe0,0x92,0x5d,0xcf,0xb3,0x5a,0xce,0x1a,0xbd,0x31,0x17,0xf4,0x3d,0xd3,0x05,0x69
};

/**
 * The platform ID for the PCD with components with maximum length type fields.
 */
const char PCD_MAX_LEN_COMPONENTS_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with components with maximum length type fields.
 */
const struct pcd_testing_data PCD_MAX_LEN_COMPONENTS_TESTING = {
	.manifest = {
		.raw = PCD_MAX_LEN_COMPONENTS_DATA,
		.length = sizeof (PCD_MAX_LEN_COMPONENTS_DATA),
		.hash = PCD_MAX_LEN_COMPONENTS_HASH,
		.hash_len = sizeof (PCD_MAX_LEN_COMPONENTS_HASH),
		.id = 0x1a,
		.signature = PCD_MAX_LEN_COMPONENTS_DATA + (sizeof (PCD_MAX_LEN_COMPONENTS_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_MAX_LEN_COMPONENTS_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_MAX_LEN_COMPONENTS_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_MAX_LEN_COMPONENTS_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_MAX_LEN_COMPONENTS_DATA + 0x0148,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_MAX_LEN_COMPONENTS_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_MAX_LEN_COMPONENTS_PLATFORM_ID) - 1,
		.plat_id_str_pad = 1,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0378,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0150,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0110,
	.bridge_component_offset = 0x0268,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x010c,
	.direct_component_offset = 0x015c,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x0380,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * PCD with ports with filtered bypass flash modes and pulse reset control for testing.
 */
const uint8_t PCD_FILTERED_BYPASS_PULSE_RESET_DATA[] = {
	0x9c,0x02,0x29,0x10,0x1a,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x07,0x00,0x00,
	0x00,0xff,0x01,0x00,0x48,0x01,0x08,0x00,0x42,0xff,0x01,0x01,0x50,0x01,0x0c,0x00,
	0x43,0xff,0x01,0x02,0x5c,0x01,0x14,0x00,0x44,0xff,0x01,0x03,0x70,0x01,0x14,0x00,
	0x40,0xff,0x01,0x04,0x84,0x01,0x08,0x00,0x41,0x40,0x01,0x05,0x8c,0x01,0x08,0x00,
	0x41,0x40,0x01,0x06,0x94,0x01,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0x4d,0x9a,0x65,0x85,0x38,0xe7,0x61,0xba,
	0xbb,0xb3,0xdc,0x6a,0x01,0x3f,0xb4,0x11,0x77,0x16,0x30,0x68,0x93,0x9c,0xc5,0x89,
	0xf1,0xd1,0x9a,0x66,0xab,0xc9,0x09,0x7f,0x1e,0x1d,0x1a,0xe3,0x7c,0xef,0x8e,0xdd,
	0x91,0x64,0x59,0x14,0x19,0xf4,0x5d,0x67,0x74,0xc3,0x8d,0x5e,0xc9,0x77,0x2e,0xf2,
	0xc8,0x79,0xac,0x7f,0x2d,0x5e,0x78,0x52,0x76,0x05,0xa2,0x2a,0xcd,0x69,0xcd,0x01,
	0xf7,0x2c,0x5e,0x18,0xc7,0xe1,0xbb,0x27,0x77,0xed,0x3d,0x11,0xd9,0x2b,0xe4,0x3d,
	0xbd,0x58,0x28,0x98,0xf3,0x2b,0x63,0xc1,0x26,0x68,0x8f,0x48,0xef,0xdf,0x2c,0x20,
	0xf7,0xe5,0x49,0xea,0x14,0x17,0x44,0x8e,0x82,0xc3,0x96,0x38,0xbf,0x9a,0xb9,0x53,
	0xd2,0xa1,0xc0,0x94,0x27,0xf5,0xa9,0x60,0xdc,0x5c,0x83,0x90,0x3d,0x28,0x78,0xad,
	0x89,0xc3,0xa1,0xa6,0xa1,0x88,0x02,0x87,0x8e,0x24,0x19,0x4f,0x6c,0x59,0x80,0x30,
	0x98,0xa2,0x45,0xed,0x01,0x26,0x4d,0x2b,0x7b,0xbe,0xda,0xd8,0x73,0x6b,0x03,0xb8,
	0x24,0xc9,0x8d,0xd2,0xa6,0x5d,0x7c,0x0f,0xb2,0xc6,0x19,0x73,0xcf,0x10,0x70,0x06,
	0x18,0xad,0xce,0xcc,0x09,0xcb,0xd3,0x92,0xcb,0x1e,0x5f,0x67,0x68,0x5f,0xc0,0x87,
	0x9f,0xbc,0xa2,0xe5,0x39,0xa3,0xcc,0x0c,0x19,0x1e,0x54,0xf5,0x79,0xde,0x47,0x20,
	0x3b,0x4d,0xdb,0x6b,0xd2,0xcc,0x01,0x5d,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0x02,0x02,0x22,0x14,0x66,0x07,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x50,0xe0,0x05,
	0x41,0x6c,0x70,0x68,0x61,0x00,0x00,0x00,0x01,0x03,0x75,0x77,0x55,0x03,0x00,0x00,
	0x00,0x70,0xf0,0x04,0x42,0x65,0x74,0x61,0x0a,0x00,0x0b,0x00,0x0c,0x00,0x0d,0x00,
	0x02,0x30,0x00,0x00,0x00,0x02,0x02,0x41,0x0b,0x10,0x0a,0x00,0x00,0x3a,0x00,0x00,
	0x00,0x48,0xe8,0x01,0x01,0x0c,0x01,0x0a,0x00,0x90,0xd0,0x03,0x05,0xa7,0xc5,0x18,
	0x10,0xc8,0x42,0x17,0x91,0xe1,0xa7,0x65,0xbb,0x48,0x5c,0x16,0xc1,0x09,0x42,0x1b,
	0xb7,0xa6,0x0b,0x0d,0xc8,0x36,0xaa,0x50,0x8b,0x7d,0xb5,0x48,0xc6,0xb8,0x77,0x91,
	0x0d,0x59,0x3f,0x36,0x16,0xb4,0x52,0x7f,0x1c,0x4c,0xb7,0x16,0xfc,0x0d,0x39,0xd6,
	0xa7,0x32,0xe7,0x69,0x46,0xfa,0x43,0x00,0x8a,0x67,0x5d,0xea,0x68,0x4d,0x97,0xb2,
	0xed,0x01,0xe5,0xe7,0x61,0x6e,0xbd,0x9a,0xb3,0xaf,0x76,0x18,0xe4,0x13,0x23,0x23,
	0x32,0xcf,0x5f,0x4b,0xca,0xc1,0x3f,0x85,0xe5,0x93,0xef,0x04,0x02,0x24,0x3d,0xbc,
	0x7f,0xd8,0x52,0x99,0xa0,0x24,0xa6,0x00,0x64,0xf5,0x3b,0xa1,0x50,0x99,0xe4,0x84,
	0xb4,0xd9,0xc3,0x26,0xd9,0xb9,0xde,0x90,0xa3,0xd9,0x65,0x0e,0x2b,0x14,0x42,0xab,
	0x81,0xab,0x65,0x34,0x47,0x54,0x5f,0xf6,0xed,0x89,0x51,0xba,0xa4,0x75,0x31,0x1b,
	0xfa,0xe9,0xea,0x27,0xc0,0x0a,0x0e,0x46,0x65,0x36,0x0d,0x20,0xe5,0xe6,0x23,0x27,
	0x2e,0xf3,0x3a,0xe3,0xb1,0xde,0xf2,0x30,0x8b,0x53,0xb2,0xcb,0x6d,0x7a,0xd7,0xe8,
	0xe8,0x81,0xc3,0xa3,0xb6,0xa7,0xc0,0x6f,0x9a,0x3c,0x2a,0x72,0xc7,0x1d,0x11,0xc7,
	0xb3,0x69,0x87,0x47,0x7c,0x71,0xec,0x45,0xc3,0x8e,0x12,0x64,0x90,0xc3,0x39,0x26,
	0xdd,0x05,0x40,0x78,0xd0,0x75,0xc2,0xff,0x62,0xf3,0x8d,0xf6,0x37,0x5d,0xdb,0xff,
	0x93,0x74,0xb7,0x62,0x84,0x9e,0xb2,0x22,0x23,0x48,0x98,0x06,0x8b,0x68,0xc2,0x9e,
	0x7e,0x57,0x70,0xcc,0xaf,0x40,0xa5,0x2a,0x44,0x1a,0x4e,0x4e
};

/**
 * Length of the testing PCD with ports with filtered bypass flash modes and pulse reset control.
 */
const uint32_t PCD_FILTERED_BYPASS_PULSE_RESET_DATA_LEN =
	sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_DATA);

/**
 * PCD_FILTERED_BYPASS_PULSE_RESET_DATA hash for testing.
 */
const uint8_t PCD_FILTERED_BYPASS_PULSE_RESET_HASH[] = {
	0x96,0x6b,0x4c,0x29,0xa2,0xa9,0xc0,0x68,0x75,0x79,0x09,0x80,0x39,0x1b,0x16,0xd8,
	0x6f,0xed,0xa4,0x0e,0x73,0xc4,0x14,0xf3,0x14,0x64,0x4a,0x53,0x9b,0x6f,0xfa,0x2d
};

/**
 * The platform ID for the PCD with ports with filtered bypass flash modes and pulse reset control.
 */
const char PCD_FILTERED_BYPASS_PULSE_RESET_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test PCD with ports with filtered bypass flash modes and pulse reset control.
 */
const struct pcd_testing_data PCD_FILTERED_BYPASS_PULSE_RESET_TESTING = {
	.manifest = {
		.raw = PCD_FILTERED_BYPASS_PULSE_RESET_DATA,
		.length = sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_DATA),
		.hash = PCD_FILTERED_BYPASS_PULSE_RESET_HASH,
		.hash_len = sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_HASH),
		.id = 0x1a,
		.signature = PCD_FILTERED_BYPASS_PULSE_RESET_DATA +
			(sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_FILTERED_BYPASS_PULSE_RESET_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x013c,
		.toc_hash = PCD_FILTERED_BYPASS_PULSE_RESET_DATA + 0x0128,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0128,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 7,
		.toc_hashes = 7,
		.plat_id = PCD_FILTERED_BYPASS_PULSE_RESET_DATA + 0x0148,
		.plat_id_len = 0x0008,
		.plat_id_str = PCD_FILTERED_BYPASS_PULSE_RESET_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_FILTERED_BYPASS_PULSE_RESET_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0148,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0x0008,
	.rot_offset = 0x0184,
	.rot_entry = 4,
	.rot_hash = 4,
	.power_ctrl_len = 0x000c,
	.power_ctrl_offset = 0x0150,
	.power_ctrl_entry = 1,
	.power_ctrl_hash = 1,
	.bridge_component_len = 0x0014,
	.bridge_component_offset = 0x0170,
	.bridge_component_entry = 3,
	.bridge_component_hash = 3,
	.direct_component_len = 0x0014,
	.direct_component_offset = 0x015c,
	.direct_component_entry = 2,
	.direct_component_hash = 2,
	.port_len = 0x0008,
	.port_offset = 0x018c,
	.port_entry = 5,
	.port_hash = 5,
	.num_optional_elements = 5,
};

/**
 * Empty PCD for testing.
 */
const uint8_t PCD_EMPTY_DATA[] = {
	0x60,0x01,0x29,0x10,0x20,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x00,
	0x00,0xff,0x01,0x00,0x58,0x00,0x08,0x00,0x13,0xe9,0x1c,0x16,0x0e,0xcf,0xd2,0xbb,
	0x3a,0x86,0x83,0xb6,0x01,0xc4,0xba,0xcb,0x04,0xf0,0xa5,0x18,0x9b,0x97,0xd9,0x2d,
	0x67,0xf4,0x6d,0x69,0xea,0x1e,0x25,0x36,0xdc,0x10,0x83,0x7f,0x37,0xb5,0x77,0xd9,
	0x7e,0x1b,0xb5,0xf2,0xbf,0x58,0xf4,0xd7,0xa2,0x05,0xf2,0xc9,0x76,0xcb,0x32,0x0e,
	0xa2,0xd3,0xbe,0x32,0xbe,0x76,0x0c,0x0b,0x04,0x00,0x00,0x00,0x53,0x4b,0x55,0x31,
	0xa8,0x6c,0x1b,0xf8,0x53,0xff,0xec,0x09,0x32,0x93,0xb6,0xd0,0x70,0x22,0x15,0x41,
	0x5b,0x80,0xbb,0x27,0xe3,0x6c,0x13,0xeb,0xc6,0xc9,0x9d,0x90,0x80,0x48,0x06,0x5c,
	0x39,0xcc,0x96,0x5a,0xfc,0x9f,0x73,0x45,0x28,0xfa,0x52,0xcd,0xf5,0x94,0x8e,0x54,
	0x62,0x8f,0xf2,0xce,0x76,0x8e,0x1e,0xf4,0x44,0x77,0x03,0x42,0x29,0xca,0xc2,0xd2,
	0xf2,0x2a,0xe8,0x06,0x1c,0x05,0xda,0xee,0xe3,0x62,0x89,0xb2,0xf1,0x37,0x52,0x4c,
	0x05,0x01,0xcd,0x18,0x22,0x83,0xa7,0xd7,0xd6,0xef,0xfc,0x4c,0xc9,0x04,0x90,0x55,
	0x36,0xb9,0x77,0x89,0xe3,0x77,0x42,0x32,0x93,0x09,0x01,0x65,0x09,0xf3,0xe2,0x2c,
	0x08,0xf0,0x6e,0x38,0xec,0x47,0x09,0xc2,0x43,0x45,0xd9,0xf1,0x54,0xa0,0x85,0x93,
	0x1e,0x28,0xbb,0xe9,0xf0,0x64,0x69,0x80,0x77,0x94,0xc7,0xc9,0x30,0xd8,0xbe,0x49,
	0xd1,0x4e,0xad,0x22,0x21,0x06,0x12,0x8b,0xf7,0xd7,0xcb,0xb7,0x65,0x8e,0x87,0x05,
	0x33,0x52,0x4e,0xdb,0xbe,0x5f,0xcb,0x74,0xb9,0x19,0x98,0xb5,0xa8,0x0c,0xfa,0x83,
	0xb3,0xa6,0x6a,0xcc,0xe8,0x4f,0xc5,0xac,0x71,0x47,0xd8,0x62,0xd5,0x37,0x96,0x5e,
	0x64,0x30,0x20,0xc4,0xcf,0x7f,0x5c,0x50,0x5d,0x16,0xd7,0x4e,0xbf,0x46,0x58,0x18,
	0xc3,0xef,0xbb,0xa1,0x41,0xa1,0xad,0xb1,0x59,0xe4,0x6c,0x9e,0xa6,0x83,0x0d,0x93,
	0xfa,0xb7,0xc6,0x94,0xed,0x43,0x43,0x4c,0x82,0x56,0xd9,0x93,0x89,0x76,0x14,0x8f,
	0xec,0xb7,0x7a,0x1e,0x63,0x17,0xc5,0x9a,0x49,0xc1,0x79,0x2b,0x42,0x41,0x70,0x60
};

/**
 * Length of the testing empty PCD.
 */
const uint32_t PCD_EMPTY_DATA_LEN = sizeof (PCD_EMPTY_DATA);

/**
 * PCD_DATA_EMPTY hash for testing.
 */
const uint8_t PCD_EMPTY_HASH[] = {
	0xf1,0xc7,0xcb,0xf1,0x74,0xa8,0x85,0x3e,0xbc,0x13,0xb7,0x73,0xd1,0xeb,0x7a,0x52,
	0x69,0x8e,0x0a,0x94,0x45,0x36,0x06,0xe3,0x00,0x7b,0xa6,0xf4,0x68,0xcf,0x95,0xe1
};

/**
 * The platform ID for the empty PCD.
 */
const char PCD_EMPTY_PLATFORM_ID[] = "SKU1";

/**
 * Components of the test empty PCD.
 */
const struct pcd_testing_data PCD_EMPTY_TESTING = {
	.manifest = {
		.raw = PCD_EMPTY_DATA,
		.length = sizeof (PCD_EMPTY_DATA),
		.hash = PCD_EMPTY_HASH,
		.hash_len = sizeof (PCD_EMPTY_HASH),
		.id = 0x20,
		.signature = PCD_EMPTY_DATA + (sizeof (PCD_EMPTY_DATA) - 256),
		.sig_len = 256,
		.sig_offset = (sizeof (PCD_EMPTY_DATA) - 256),
		.sig_hash_type = HASH_TYPE_SHA256,
		.toc = PCD_EMPTY_DATA + MANIFEST_V2_TOC_HDR_OFFSET,
		.toc_len = 0x0044,
		.toc_hash = PCD_EMPTY_DATA + 0x0038,
		.toc_hash_len = 32,
		.toc_hash_offset = 0x0038,
		.toc_hash_type = HASH_TYPE_SHA256,
		.toc_entries = 1,
		.toc_hashes = 1,
		.plat_id = PCD_EMPTY_DATA + 0x0058,
		.plat_id_len = 0x008,
		.plat_id_str = PCD_EMPTY_PLATFORM_ID,
		.plat_id_str_len = sizeof (PCD_EMPTY_PLATFORM_ID) - 1,
		.plat_id_str_pad = 0,
		.plat_id_offset = 0x0058,
		.plat_id_entry = 0,
		.plat_id_hash = 0
	},
	.rot_len = 0,
	.rot_offset = 0,
	.rot_entry = -1,
	.rot_hash = -1,
	.power_ctrl_len = 0,
	.power_ctrl_offset = 0,
	.power_ctrl_entry = -1,
	.power_ctrl_hash = -1,
	.bridge_component_len = 0,
	.bridge_component_offset = 0,
	.bridge_component_entry = -1,
	.bridge_component_hash = -1,
	.direct_component_len = 0,
	.direct_component_offset = 0,
	.direct_component_entry = -1,
	.direct_component_hash = -1,
	.port_len = 0,
	.port_offset = 0,
	.port_entry = -1,
	.port_hash = -1,
	.num_optional_elements = 0,
};

/**
 * Dependencies for testing PCDs.
 */
struct pcd_flash_testing {
	struct manifest_flash_v2_testing manifest;			/**< Common dependencies for manifest testing. */
	struct pcd_flash test;								/**< PCD instance under test. */
};


/**
 * Initialize common PCD testing dependencies.
 *
 * @param test The testing framework.
 * @param pcd The testing components to initialize.
 * @param address The base address for the PCD data.
 */
static void pcd_flash_testing_init_dependencies (CuTest *test, struct pcd_flash_testing *pcd,
	uint32_t address)
{
	manifest_flash_v2_testing_init_dependencies (test, &pcd->manifest, address);
}

/**
 * Release test dependencies and validate all mocks.
 *
 * @param test The testing framework.
 * @param pcd The testing components to release.
 */
static void pcd_flash_testing_validate_and_release_dependencies (CuTest *test,
	struct pcd_flash_testing *pcd)
{
	manifest_flash_v2_testing_validate_and_release_dependencies (test, &pcd->manifest);
}

/**
 * Initialize PCD for testing.
 *
 * @param test The testing framework.
 * @param pcd The testing components to initialize.
 * @param address The base address for the PCD data.
 */
static void pcd_flash_testing_init (CuTest *test, struct pcd_flash_testing *pcd, uint32_t address)
{
	int status;

	pcd_flash_testing_init_dependencies (test, pcd, address);
	manifest_flash_v2_testing_init_common (test, &pcd->manifest, 0x1000);

	status = pcd_flash_init (&pcd->test, &pcd->manifest.flash.base, &pcd->manifest.hash.base,
		address, pcd->manifest.signature, sizeof (pcd->manifest.signature),
		pcd->manifest.platform_id, sizeof (pcd->manifest.platform_id));
	CuAssertIntEquals (test, 0, status);

	status = mock_validate (&pcd->manifest.flash.mock);
	CuAssertIntEquals (test, 0, status);

	status = mock_validate (&pcd->manifest.verification.mock);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Release a test instance and validate all mocks.
 *
 * @param test The testing framework.
 * @param pcd The testing components to release.
 */
static void pcd_flash_testing_validate_and_release (CuTest *test, struct pcd_flash_testing *pcd)
{
	pcd_flash_release (&pcd->test);

	pcd_flash_testing_validate_and_release_dependencies (test, pcd);
}

/**
 * Set up expectations for verifying a PCD on flash.
 *
 * @param test The testing framework.
 * @param pcd The testing components.
 * @param testing_data Container with testing data.
 * @param sig_result Result of the signature verification call.
 */
static void pcd_flash_testing_verify_pcd (CuTest *test, struct pcd_flash_testing *pcd,
	const struct pcd_testing_data *testing_data, int sig_result)
{
	manifest_flash_v2_testing_verify_manifest (test, &pcd->manifest, &testing_data->manifest,
		sig_result);
}

/**
 * Initialize a PCD for testing.  Run verification to load the PCD information.
 *
 * @param test The testing framework.
 * @param pcd The testing components to initialize.
 * @param address The base address for the PCD data.
 * @param testing_data Container with testing data.
 * @param sig_result Result of the signature verification call.
 */
static void pcd_flash_testing_init_and_verify (CuTest *test, struct pcd_flash_testing *pcd,
	uint32_t address, const struct pcd_testing_data *testing_data, int sig_result)
{
	int status;

	pcd_flash_testing_init (test, pcd, address);
	pcd_flash_testing_verify_pcd (test, pcd, testing_data, sig_result);

	status = pcd->test.base.base.verify (&pcd->test.base.base, &pcd->manifest.hash.base,
		&pcd->manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, sig_result, status);

	status = mock_validate (&pcd->manifest.flash.mock);
	CuAssertIntEquals (test, 0, status);

	status = mock_validate (&pcd->manifest.verification.mock);
	CuAssertIntEquals (test, 0, status);
}

/*******************
 * Test cases
 *******************/

static void pcd_flash_test_init (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_dependencies (test, &pcd, 0x10000);
	manifest_flash_v2_testing_init_common (test, &pcd.manifest, 0x1000);

	status = pcd_flash_init (&pcd.test, &pcd.manifest.flash.base, &pcd.manifest.hash.base, 0x10000,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, 0, status);

	CuAssertPtrNotNull (test, pcd.test.base.base.verify);
	CuAssertPtrNotNull (test, pcd.test.base.base.get_id);
	CuAssertPtrNotNull (test, pcd.test.base.base.get_platform_id);
	CuAssertPtrNotNull (test, pcd.test.base.base.free_platform_id);
	CuAssertPtrNotNull (test, pcd.test.base.base.get_hash);
	CuAssertPtrNotNull (test, pcd.test.base.base.get_signature);
	CuAssertPtrNotNull (test, pcd.test.base.base.is_empty);

	CuAssertPtrNotNull (test, pcd.test.base.get_devices_info);
	CuAssertPtrNotNull (test, pcd.test.base.get_rot_info);
	CuAssertPtrNotNull (test, pcd.test.base.get_port_info);
	CuAssertPtrNotNull (test, pcd.test.base.get_power_controller_info);

	CuAssertIntEquals (test, 0x10000, manifest_flash_get_addr (&pcd.test.base_flash));
	CuAssertPtrEquals (test, &pcd.manifest.flash, manifest_flash_get_flash (&pcd.test.base_flash));

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_init_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_dependencies (test, &pcd, 0x10000);

	status = pcd_flash_init (NULL, &pcd.manifest.flash.base, &pcd.manifest.hash.base, 0x10000,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd_flash_init (&pcd.test, NULL, &pcd.manifest.hash.base, 0x10000,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	status = pcd_flash_init (&pcd.test, &pcd.manifest.flash.base, NULL, 0x10000,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	status = pcd_flash_init (&pcd.test, &pcd.manifest.flash.base, &pcd.manifest.hash.base, 0x10000,
		NULL, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd_flash_init (&pcd.test, NULL, &pcd.manifest.hash.base, 0x10000,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), NULL,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release_dependencies (test, &pcd);
}

static void pcd_flash_test_init_manifest_flash_init_fail (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_dependencies (test, &pcd, 0x10001);
	manifest_flash_v2_testing_init_common (test, &pcd.manifest, 0x1000);

	status = pcd_flash_init (&pcd.test, &pcd.manifest.flash.base, &pcd.manifest.hash.base, 0x10001,
		pcd.manifest.signature, sizeof (pcd.manifest.signature), pcd.manifest.platform_id,
		sizeof (pcd.manifest.platform_id));
	CuAssertIntEquals (test, MANIFEST_STORAGE_NOT_ALIGNED, status);

	pcd_flash_testing_validate_and_release_dependencies (test, &pcd);
}

static void pcd_flash_test_release_null (CuTest *test)
{
	TEST_START;

	pcd_flash_release (NULL);
}

static void pcd_flash_test_verify (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_no_power_controller (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_NO_POWER_CONTROLLER_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_no_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_NO_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_no_ports (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_NO_PORTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_no_ports_power_controller_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_NO_PORTS_POWER_CONTROLLER_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_only_direct_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_ONLY_DIRECT_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_multiple_direct_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_only_bridge_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_ONLY_BRIDGE_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_multiple_bridge_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_max_len_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_MAX_LEN_COMPONENTS_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_filtered_bypass_pulse_reset (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_FILTERED_BYPASS_PULSE_RESET_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_empty_manifest (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	pcd_flash_testing_verify_pcd (test, &pcd, &PCD_EMPTY_TESTING, 0);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.base.verify (NULL, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.verify (&pcd.test.base.base, NULL, &pcd.manifest.verification.base,
		NULL, 0);
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base, NULL, NULL,
		0);
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_read_header_fail (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (pcd.manifest.addr), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_verify_bad_magic_number (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	uint8_t pcd_bad_data[MANIFEST_V2_HEADER_SIZE];

	TEST_START;

	memcpy (pcd_bad_data, PCD_TESTING.manifest.raw, sizeof (pcd_bad_data));
	pcd_bad_data[2] ^= 0x55;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (pcd.manifest.addr), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, pcd_bad_data,
		MANIFEST_V2_HEADER_SIZE, 2);
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.verify (&pcd.test.base.base, &pcd.manifest.hash.base,
		&pcd.manifest.verification.base, NULL, 0);
	CuAssertIntEquals (test, MANIFEST_BAD_MAGIC_NUMBER, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_id (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	uint32_t id;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_id (&pcd.test.base.base, &id);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 0x1A, id);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_id_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	uint32_t id;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_id (NULL, &id);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.get_id (&pcd.test.base.base, NULL);
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_id_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	uint32_t id;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.base.get_id (&pcd.test.base.base, &id);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_hash (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t hash_out[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	/* Read manifest header. */
	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (0x10000), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, PCD_TESTING.manifest.raw,
		MANIFEST_V2_HEADER_SIZE, 2);

	status |= flash_mock_expect_verify_flash (&pcd.manifest.flash, 0x10000,
		PCD_TESTING.manifest.raw, PCD_DATA_LEN - PCD_TESTING.manifest.sig_len);

	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.get_hash (&pcd.test.base.base, &pcd.manifest.hash.base, hash_out,
		sizeof (hash_out));
	CuAssertIntEquals (test, SHA256_HASH_LENGTH, status);

	status = testing_validate_array (PCD_TESTING.manifest.hash, hash_out,
		PCD_TESTING.manifest.hash_len);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_hash_after_verify (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t hash_out[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_hash (&pcd.test.base.base, &pcd.manifest.hash.base, hash_out,
		sizeof (hash_out));
	CuAssertIntEquals (test, SHA256_HASH_LENGTH, status);

	status = testing_validate_array (PCD_TESTING.manifest.hash, hash_out,
		PCD_TESTING.manifest.hash_len);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_hash_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t hash_out[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_hash (NULL, &pcd.manifest.hash.base, hash_out,
		sizeof (hash_out));
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.get_hash (&pcd.test.base.base, NULL, hash_out,
		sizeof (hash_out));
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.get_hash (&pcd.test.base.base, &pcd.manifest.hash.base, NULL,
		sizeof (hash_out));
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_hash_bad_magic_num (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t hash_out[SHA256_HASH_LENGTH];
	int status;
	uint8_t pcd_bad_data[PCD_TESTING.manifest.sig_offset];

	TEST_START;

	memcpy (pcd_bad_data, PCD_TESTING.manifest.raw, sizeof (pcd_bad_data));
	pcd_bad_data[2] ^= 0x55;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (pcd.manifest.addr), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, pcd_bad_data,
		MANIFEST_V2_HEADER_SIZE, 2);
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.get_hash (&pcd.test.base.base, &pcd.manifest.hash.base, hash_out,
		sizeof (hash_out));
	CuAssertIntEquals (test, MANIFEST_BAD_MAGIC_NUMBER, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_signature (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t sig_out[PCD_TESTING.manifest.sig_len];
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (pcd.manifest.addr), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, PCD_TESTING.manifest.raw,
		MANIFEST_V2_HEADER_SIZE, 2);

	status |= mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (pcd.manifest.addr + PCD_TESTING.manifest.sig_offset),
		MOCK_ARG_NOT_NULL, MOCK_ARG (PCD_TESTING.manifest.sig_len));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, PCD_TESTING.manifest.signature,
		PCD_TESTING.manifest.sig_len, 2);

	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.get_signature (&pcd.test.base.base, sig_out, sizeof (sig_out));
	CuAssertIntEquals (test, PCD_TESTING.manifest.sig_len, status);

	status = testing_validate_array (PCD_TESTING.manifest.signature, sig_out,
		PCD_TESTING.manifest.sig_len);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_signature_after_verify (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t sig_out[PCD_TESTING.manifest.sig_len];
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_signature (&pcd.test.base.base, sig_out, sizeof (sig_out));
	CuAssertIntEquals (test, PCD_TESTING.manifest.sig_len, status);

	status = testing_validate_array (PCD_TESTING.manifest.signature, sig_out,
		PCD_TESTING.manifest.sig_len);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_signature_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t sig_out[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_signature (NULL, sig_out, sizeof (sig_out));
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.get_signature (&pcd.test.base.base, NULL, sizeof (sig_out));
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_signature_bad_magic_number (CuTest *test)
{
	struct pcd_flash_testing pcd;
	uint8_t sig_out[SHA256_HASH_LENGTH];
	int status;
	uint8_t pcd_bad_data[MANIFEST_V2_HEADER_SIZE];

	TEST_START;

	memcpy (pcd_bad_data, PCD_TESTING.manifest.raw, sizeof (pcd_bad_data));
	pcd_bad_data[2] ^= 0x55;

	pcd_flash_testing_init (test, &pcd, 0x10000);



	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, 0, MOCK_ARG (pcd.manifest.addr), MOCK_ARG_NOT_NULL,
		MOCK_ARG (MANIFEST_V2_HEADER_SIZE));
	status |= mock_expect_output (&pcd.manifest.flash.mock, 1, pcd_bad_data,
		MANIFEST_V2_HEADER_SIZE, 2);

	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.base.get_signature (&pcd.test.base.base, sig_out, sizeof (sig_out));
	CuAssertIntEquals (test, MANIFEST_BAD_MAGIC_NUMBER, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_platform_id (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	char buffer[32];
	char *id = buffer;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_platform_id (&pcd.test.base.base, &id, sizeof (buffer));
	CuAssertIntEquals (test, 0, status);
	CuAssertPtrEquals (test, buffer, id);
	CuAssertStrEquals (test, PCD_TESTING.manifest.plat_id_str, id);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_platform_id_manifest_allocation (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	char *id = NULL;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_platform_id (&pcd.test.base.base, &id, 0);
	CuAssertIntEquals (test, 0, status);
	CuAssertPtrNotNull (test, id);
	CuAssertStrEquals (test, PCD_TESTING.manifest.plat_id_str, id);

	pcd.test.base.base.free_platform_id (&pcd.test.base.base, id);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_platform_id_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	char *id = NULL;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.get_platform_id (NULL, &id, 0);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.base.get_platform_id (&pcd.test.base.base, NULL, 0);
	CuAssertIntEquals (test, MANIFEST_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_platform_id_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;
	char buffer[32];
	char *id = buffer;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.base.get_platform_id (&pcd.test.base.base, &id, sizeof (buffer));
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.direct_component_entry, 0, PCD_TESTING.direct_component_hash,
		PCD_TESTING.direct_component_offset, PCD_TESTING.direct_component_len, 20, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest, -1, 3, -1,
		0, 0, 0, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.bridge_component_entry, 0, PCD_TESTING.bridge_component_hash,
		PCD_TESTING.bridge_component_offset, PCD_TESTING.bridge_component_len, 20, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 2, num_devices);
	CuAssertIntEquals (test, 0x75, info[0].smbus_addr);
	CuAssertIntEquals (test, 0x77, info[0].eid);
	CuAssertIntEquals (test, 0x30, info[1].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.get_devices_info (NULL, &info, &num_devices);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.get_devices_info (&pcd.test.base, NULL, &num_devices);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, NULL);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_no_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_NO_COMPONENTS_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_NO_COMPONENTS_TESTING.manifest, PCD_NO_COMPONENTS_TESTING.rot_entry, 0,
		PCD_NO_COMPONENTS_TESTING.rot_hash, PCD_NO_COMPONENTS_TESTING.rot_offset,
		PCD_NO_COMPONENTS_TESTING.rot_len, PCD_TESTING.rot_len, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 0, num_devices);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_only_direct_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_ONLY_DIRECT_COMPONENTS_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_DIRECT_COMPONENTS_TESTING.manifest, PCD_ONLY_DIRECT_COMPONENTS_TESTING.rot_entry,
		0, PCD_ONLY_DIRECT_COMPONENTS_TESTING.rot_hash,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.rot_offset, PCD_ONLY_DIRECT_COMPONENTS_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_entry, 0,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_hash,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_offset,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_len,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_entry + 1,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_entry + 1,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_hash + 1,
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_offset +
		PCD_ONLY_DIRECT_COMPONENTS_TESTING.direct_component_len, 16, 16, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 2, num_devices);
	CuAssertIntEquals (test, 0x75, info[0].smbus_addr);
	CuAssertIntEquals (test, 0x77, info[0].eid);
	CuAssertIntEquals (test, 0x88, info[1].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_multiple_direct_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING,
		0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.rot_entry, 0,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.rot_hash,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.rot_offset,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_entry, 0,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_hash,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_offset,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_len,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_entry + 1,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_entry + 1,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_hash + 1,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_offset +
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_len,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_len,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.manifest, -1,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.direct_component_entry + 2, -1, 0, 0, 0, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.bridge_component_entry, 0,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.bridge_component_hash,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.bridge_component_offset,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.bridge_component_len,
		PCD_MULTIPLE_DIRECT_COMPONENTS_TESTING.bridge_component_len, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 3, num_devices);
	CuAssertIntEquals (test, 0x75, info[0].smbus_addr);
	CuAssertIntEquals (test, 0x77, info[0].eid);
	CuAssertIntEquals (test, 0x81, info[1].smbus_addr);
	CuAssertIntEquals (test, 0x88, info[1].eid);
	CuAssertIntEquals (test, 0x30, info[2].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_only_bridge_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_ONLY_BRIDGE_COMPONENTS_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_BRIDGE_COMPONENTS_TESTING.manifest, PCD_ONLY_BRIDGE_COMPONENTS_TESTING.rot_entry,
		0, PCD_ONLY_BRIDGE_COMPONENTS_TESTING.rot_hash,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.rot_offset, PCD_ONLY_BRIDGE_COMPONENTS_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_BRIDGE_COMPONENTS_TESTING.manifest, -1, 0, -1, 0, 0, 0, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_entry, 0,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_hash,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_offset,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_len,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_ONLY_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_entry + 1,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_entry + 1,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_hash + 1,
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_offset +
		PCD_ONLY_BRIDGE_COMPONENTS_TESTING.bridge_component_len, 24, 24, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 2, num_devices);
	CuAssertIntEquals (test, 0x30, info[0].eid);
	CuAssertIntEquals (test, 0x35, info[1].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_multiple_bridge_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING,
		0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.rot_entry, 0,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.rot_hash,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.rot_offset,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_entry, 0,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_hash,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_offset,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_len,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.manifest, -1,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.direct_component_entry + 1, -1, 0, 0, 0, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_entry, 0,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_hash,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_offset,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_len,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.manifest,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_entry + 1,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_entry + 1,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_hash + 1,
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_offset +
		PCD_MULTIPLE_BRIDGE_COMPONENTS_TESTING.bridge_component_len, 24, 24, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 3, num_devices);
	CuAssertIntEquals (test, 0x75, info[0].smbus_addr);
	CuAssertIntEquals (test, 0x77, info[0].eid);
	CuAssertIntEquals (test, 0x30, info[1].eid);
	CuAssertIntEquals (test, 0x35, info[2].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_max_len_components (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_MAX_LEN_COMPONENTS_TESTING,
		0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MAX_LEN_COMPONENTS_TESTING.manifest, PCD_MAX_LEN_COMPONENTS_TESTING.rot_entry, 0,
		PCD_MAX_LEN_COMPONENTS_TESTING.rot_hash, PCD_MAX_LEN_COMPONENTS_TESTING.rot_offset,
		PCD_MAX_LEN_COMPONENTS_TESTING.rot_len, PCD_MAX_LEN_COMPONENTS_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MAX_LEN_COMPONENTS_TESTING.manifest,
		PCD_MAX_LEN_COMPONENTS_TESTING.direct_component_entry, 0,
		PCD_MAX_LEN_COMPONENTS_TESTING.direct_component_hash,
		PCD_MAX_LEN_COMPONENTS_TESTING.direct_component_offset,
		PCD_MAX_LEN_COMPONENTS_TESTING.direct_component_len,
		sizeof (struct pcd_direct_i2c_component_element), 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MAX_LEN_COMPONENTS_TESTING.manifest, -1,
		PCD_MAX_LEN_COMPONENTS_TESTING.direct_component_entry + 1, -1, 0, 0, 0, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_MAX_LEN_COMPONENTS_TESTING.manifest,
		PCD_MAX_LEN_COMPONENTS_TESTING.bridge_component_entry, 0,
		PCD_MAX_LEN_COMPONENTS_TESTING.bridge_component_hash,
		PCD_MAX_LEN_COMPONENTS_TESTING.bridge_component_offset,
		PCD_MAX_LEN_COMPONENTS_TESTING.bridge_component_len,
		PCD_MAX_LEN_COMPONENTS_TESTING.bridge_component_len, 0);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 2, num_devices);
	CuAssertIntEquals (test, 0x75, info[0].smbus_addr);
	CuAssertIntEquals (test, 0x77, info[0].eid);
	CuAssertIntEquals (test, 0x30, info[1].eid);

	platform_free (info);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_rot_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_direct_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_devices_info_bridge_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct device_manager_info *info;
	size_t num_devices;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.direct_component_entry, 0, PCD_TESTING.direct_component_hash,
		PCD_TESTING.direct_component_offset, PCD_TESTING.direct_component_len, 20, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest, -1, 3, -1,
		0, 0, 0, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_devices_info (&pcd.test.base, &info, &num_devices);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_rot_info (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_rot_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	status = pcd.test.base.get_rot_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 1, info.is_pa_rot);
	CuAssertIntEquals (test, 2, info.port_count);
	CuAssertIntEquals (test, 2, info.components_count);
	CuAssertIntEquals (test, 0x41, info.i2c_slave_addr);
	CuAssertIntEquals (test, 0x0B, info.eid);
	CuAssertIntEquals (test, 0x10, info.bridge_i2c_addr);
	CuAssertIntEquals (test, 0x0A, info.bridge_eid);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_rot_info_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_rot_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.get_rot_info (NULL, &info);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.get_rot_info (&pcd.test.base, NULL);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_rot_info_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_rot_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.get_rot_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_rot_info_rot_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_rot_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_rot_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.port_entry, PCD_TESTING.port_entry, PCD_TESTING.port_hash,
		PCD_TESTING.port_offset, PCD_TESTING.port_len, PCD_TESTING.port_len, 0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 32000000, info.spi_freq);
	CuAssertIntEquals (test, 0, info.flash_mode);
	CuAssertIntEquals (test, 1, info.reset_ctrl);
	CuAssertIntEquals (test, 0, info.policy);
	CuAssertIntEquals (test, 1, info.runtime_verification);
	CuAssertIntEquals (test, 1, info.watchdog_monitoring);
	CuAssertIntEquals (test, 0, info.pulse_interval);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.port_entry, PCD_TESTING.port_entry, PCD_TESTING.port_hash,
		PCD_TESTING.port_offset, PCD_TESTING.port_len, PCD_TESTING.port_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.port_entry + 1, PCD_TESTING.port_entry + 1, PCD_TESTING.port_hash + 1,
		PCD_TESTING.port_offset + PCD_TESTING.port_len, PCD_TESTING.port_len, PCD_TESTING.port_len,
		0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 1, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 64000000, info.spi_freq);
	CuAssertIntEquals (test, 1, info.flash_mode);
	CuAssertIntEquals (test, 0, info.reset_ctrl);
	CuAssertIntEquals (test, 1, info.policy);
	CuAssertIntEquals (test, 0, info.runtime_verification);
	CuAssertIntEquals (test, 0, info.watchdog_monitoring);
	CuAssertIntEquals (test, 10, info.pulse_interval);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_filtered_bypass_flash_modes_and_pulse_reset_control (
	CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.manifest,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_entry, 0,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_hash,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_offset,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.manifest,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_hash,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_offset,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len, 0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 32000000, info.spi_freq);
	CuAssertIntEquals (test, 2, info.flash_mode);
	CuAssertIntEquals (test, 2, info.reset_ctrl);
	CuAssertIntEquals (test, 0, info.policy);
	CuAssertIntEquals (test, 1, info.runtime_verification);
	CuAssertIntEquals (test, 1, info.watchdog_monitoring);
	CuAssertIntEquals (test, 0, info.pulse_interval);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.manifest,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_entry, 0,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_hash,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_offset,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.manifest,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_hash,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_offset,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.manifest,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry + 1,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_entry + 1,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_hash + 1,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_offset +
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len,
		PCD_FILTERED_BYPASS_PULSE_RESET_TESTING.port_len, 0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 1, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 64000000, info.spi_freq);
	CuAssertIntEquals (test, 3, info.flash_mode);
	CuAssertIntEquals (test, 0, info.reset_ctrl);
	CuAssertIntEquals (test, 1, info.policy);
	CuAssertIntEquals (test, 0, info.runtime_verification);
	CuAssertIntEquals (test, 0, info.watchdog_monitoring);
	CuAssertIntEquals (test, 10, info.pulse_interval);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.get_port_info (NULL, 0, &info);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, NULL);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, &info);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_no_ports (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_NO_PORTS_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_NO_PORTS_TESTING.manifest,
		PCD_NO_PORTS_TESTING.rot_entry, 0, PCD_NO_PORTS_TESTING.rot_hash,
		PCD_NO_PORTS_TESTING.rot_offset, PCD_NO_PORTS_TESTING.rot_len, PCD_NO_PORTS_TESTING.rot_len,
		0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, &info);
	CuAssertIntEquals (test, PCD_INVALID_PORT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_port_id_invalid (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.rot_entry, 0, PCD_TESTING.rot_hash, PCD_TESTING.rot_offset, PCD_TESTING.rot_len,
		PCD_TESTING.rot_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.port_entry, PCD_TESTING.port_entry, PCD_TESTING.port_hash,
		PCD_TESTING.port_offset, PCD_TESTING.port_len, PCD_TESTING.port_len, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.port_entry + 1, PCD_TESTING.port_entry + 1, PCD_TESTING.port_hash + 1,
		PCD_TESTING.port_offset + PCD_TESTING.port_len, PCD_TESTING.port_len, PCD_TESTING.port_len,
		0);

	status = pcd.test.base.get_port_info (&pcd.test.base, 2, &info);
	CuAssertIntEquals (test, PCD_INVALID_PORT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_port_info_rot_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_port_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_port_info (&pcd.test.base, 0, &info);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_power_controller_info (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_power_controller_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest, &PCD_TESTING.manifest,
		PCD_TESTING.power_ctrl_entry, 0, PCD_TESTING.power_ctrl_hash, PCD_TESTING.power_ctrl_offset,
		PCD_TESTING.power_ctrl_len, sizeof (struct pcd_power_controller_element), 0);

	status = pcd.test.base.get_power_controller_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, 2, info.mux_count);
	CuAssertIntEquals (test, PCD_I2C_MODE_MULTIMASTER, info.i2c_mode);
	CuAssertIntEquals (test, 2, info.bus);
	CuAssertIntEquals (test, 0x22, info.address);
	CuAssertIntEquals (test, 0x14, info.eid);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_power_controller_info_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_power_controller_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.get_power_controller_info (NULL, &info);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	status = pcd.test.base.get_power_controller_info (&pcd.test.base, NULL);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_power_controller_info_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_power_controller_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.get_power_controller_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_power_controller_info_no_power_controller (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_power_controller_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_NO_POWER_CONTROLLER_TESTING, 0);

	manifest_flash_v2_testing_read_element (test, &pcd.manifest,
		&PCD_NO_POWER_CONTROLLER_TESTING.manifest, PCD_NO_POWER_CONTROLLER_TESTING.power_ctrl_entry,
		0, PCD_NO_POWER_CONTROLLER_TESTING.power_ctrl_hash,
		PCD_NO_POWER_CONTROLLER_TESTING.power_ctrl_offset,
		PCD_NO_POWER_CONTROLLER_TESTING.power_ctrl_len, 0, 0);

	status = pcd.test.base.get_power_controller_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, MANIFEST_ELEMENT_NOT_FOUND, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_get_power_controller_info_power_controller_read_error (CuTest *test)
{
	struct pcd_flash_testing pcd;
	struct pcd_power_controller_info info;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = mock_expect (&pcd.manifest.flash.mock, pcd.manifest.flash.base.read,
		&pcd.manifest.flash, FLASH_NO_MEMORY, MOCK_ARG (0x10000 + MANIFEST_V2_TOC_ENTRY_OFFSET),
		MOCK_ARG_NOT_NULL, MOCK_ARG (0x08));
	CuAssertIntEquals (test, 0, status);

	status = pcd.test.base.get_power_controller_info (&pcd.test.base, &info);
	CuAssertIntEquals (test, FLASH_NO_MEMORY, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_is_empty (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.is_empty (&pcd.test.base.base);
	CuAssertIntEquals (test, 0, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_is_empty_empty_manifest (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_EMPTY_TESTING, 0);

	status = pcd.test.base.base.is_empty (&pcd.test.base.base);
	CuAssertIntEquals (test, 1, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_is_empty_null (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init_and_verify (test, &pcd, 0x10000, &PCD_TESTING, 0);

	status = pcd.test.base.base.is_empty (NULL);
	CuAssertIntEquals (test, PCD_INVALID_ARGUMENT, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}

static void pcd_flash_test_is_empty_verify_never_run (CuTest *test)
{
	struct pcd_flash_testing pcd;
	int status;

	TEST_START;

	pcd_flash_testing_init (test, &pcd, 0x10000);

	status = pcd.test.base.base.is_empty (&pcd.test.base.base);
	CuAssertIntEquals (test, MANIFEST_NO_MANIFEST, status);

	pcd_flash_testing_validate_and_release (test, &pcd);
}


TEST_SUITE_START (pcd_flash);

TEST (pcd_flash_test_init);
TEST (pcd_flash_test_init_null);
TEST (pcd_flash_test_init_manifest_flash_init_fail);
TEST (pcd_flash_test_release_null);
TEST (pcd_flash_test_verify);
TEST (pcd_flash_test_verify_no_power_controller);
TEST (pcd_flash_test_verify_no_components);
TEST (pcd_flash_test_verify_no_ports);
TEST (pcd_flash_test_verify_no_ports_power_controller_components);
TEST (pcd_flash_test_verify_only_direct_components);
TEST (pcd_flash_test_verify_multiple_direct_components);
TEST (pcd_flash_test_verify_only_bridge_components);
TEST (pcd_flash_test_verify_multiple_bridge_components);
TEST (pcd_flash_test_verify_max_len_components);
TEST (pcd_flash_test_verify_filtered_bypass_pulse_reset);
TEST (pcd_flash_test_verify_empty_manifest);
TEST (pcd_flash_test_verify_null);
TEST (pcd_flash_test_verify_read_header_fail);
TEST (pcd_flash_test_verify_bad_magic_number);
TEST (pcd_flash_test_get_id);
TEST (pcd_flash_test_get_id_null);
TEST (pcd_flash_test_get_id_verify_never_run);
TEST (pcd_flash_test_get_hash);
TEST (pcd_flash_test_get_hash_after_verify);
TEST (pcd_flash_test_get_hash_null);
TEST (pcd_flash_test_get_hash_bad_magic_num);
TEST (pcd_flash_test_get_signature);
TEST (pcd_flash_test_get_signature_after_verify);
TEST (pcd_flash_test_get_signature_null);
TEST (pcd_flash_test_get_signature_bad_magic_number);
TEST (pcd_flash_test_get_platform_id);
TEST (pcd_flash_test_get_platform_id_manifest_allocation);
TEST (pcd_flash_test_get_platform_id_null);
TEST (pcd_flash_test_get_platform_id_verify_never_run);
TEST (pcd_flash_test_get_devices_info);
TEST (pcd_flash_test_get_devices_info_null);
TEST (pcd_flash_test_get_devices_info_verify_never_run);
TEST (pcd_flash_test_get_devices_info_no_components);
TEST (pcd_flash_test_get_devices_info_only_direct_components);
TEST (pcd_flash_test_get_devices_info_multiple_direct_components);
TEST (pcd_flash_test_get_devices_info_only_bridge_components);
TEST (pcd_flash_test_get_devices_info_multiple_bridge_components);
TEST (pcd_flash_test_get_devices_info_max_len_components);
TEST (pcd_flash_test_get_devices_info_rot_read_error);
TEST (pcd_flash_test_get_devices_info_direct_read_error);
TEST (pcd_flash_test_get_devices_info_bridge_read_error);
TEST (pcd_flash_test_get_rot_info);
TEST (pcd_flash_test_get_rot_info_null);
TEST (pcd_flash_test_get_rot_info_verify_never_run);
TEST (pcd_flash_test_get_rot_info_rot_read_error);
TEST (pcd_flash_test_get_port_info);
TEST (pcd_flash_test_get_port_info_filtered_bypass_flash_modes_and_pulse_reset_control);
TEST (pcd_flash_test_get_port_info_null);
TEST (pcd_flash_test_get_port_info_verify_never_run);
TEST (pcd_flash_test_get_port_info_no_ports);
TEST (pcd_flash_test_get_port_info_port_id_invalid);
TEST (pcd_flash_test_get_port_info_rot_read_error);
TEST (pcd_flash_test_get_power_controller_info);
TEST (pcd_flash_test_get_power_controller_info_null);
TEST (pcd_flash_test_get_power_controller_info_verify_never_run);
TEST (pcd_flash_test_get_power_controller_info_no_power_controller);
TEST (pcd_flash_test_get_power_controller_info_power_controller_read_error);
TEST (pcd_flash_test_is_empty);
TEST (pcd_flash_test_is_empty_empty_manifest);
TEST (pcd_flash_test_is_empty_null);
TEST (pcd_flash_test_is_empty_verify_never_run);

TEST_SUITE_END;
